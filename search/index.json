[{"content":" 类比于Chrome 浏览器和其开源的“上游”项目 Chromium。VS Code 确实是基于开源代码库构建的。而微软官方发布的版本带有一些与微软相关的功能，包括一项商标、一个插件库、一个 C# 调试器以及遥测。但如果你克隆仓库然后自行编译，这些东西都不会被加入，所以你会得到一个名为 Code - OSS 的“干净”版本（OSS，Open-source software ）。\n 我之前使用\npacman -S code 所安装的正是Code-OSS ，默认不使用微软官方扩展市场。\n我们可以通过修改/usr/lib/code/product.json解决这个问题，添加如下内容：\n\u0026#34;extensionsGallery\u0026#34;: { \u0026#34;serviceUrl\u0026#34;: \u0026#34;https://marketplace.visualstudio.com/_apis/public/gallery\u0026#34;, \u0026#34;cacheUrl\u0026#34;: \u0026#34;https://vscode.blob.core.windows.net/gallery/index\u0026#34;, \u0026#34;itemUrl\u0026#34;: \u0026#34;https://marketplace.visualstudio.com/items\u0026#34; } 重新启动Code-OSS就可以了。\n","date":"2021-12-20T00:00:00Z","image":"https://bestoko.github.io/p/code-oss-extensions/code-oss_hu8b3034d3b76254d70eabeb74d0dd9f1e_41316_120x120_fill_box_smart1_3.png","permalink":"https://bestoko.github.io/p/code-oss-extensions/","title":"ArchLinux下修改Code-OSS扩展源"},{"content":"写在前面 之前我已经在Surface Pro 上安装了Arch Linux，可是由简入奢易，由奢入艰难，习惯了的二合一设备突然不能正常触屏还是有些不爽（之前买的surface pen也成了摆设），于是我在github上找到了第三方内核。由于是第三方内核，各设备各硬件的适配情况并不完善，具体可以查看这里。\n安装驱动 导入密钥 首先我们需要导入用于签名软件包的密钥：\n$ curl -s https://raw.githubusercontent.com/linux-surface/linux-surface/master/pkg/keys/surface.asc \\  | sudo pacman-key --add - 检查完整性并本地签名 $ sudo pacman-key --finger 56C464BAAC421453 $ sudo pacman-key --lsign-key 56C464BAAC421453 添加存储库 我们需要在/etc/pacman.conf添加如下内容\n[linux-surface] Server = https://pkg.surfacelinux.com/arch/ 更新存储库数据，安装内核，启用服务 我们需要更新存储库数据，以安装linux-surface内核及其依赖项，接着启用iptsd服务以使用触摸屏。\n$ sudo pacman -Syu $ sudo pacman -S linux-surface linux-surface-headers iptsd $ sudo systemctl enable iptsd 重启以后就完工了，屏幕触摸也支持了。\n","date":"2021-12-16T01:48:01+08:00","image":"https://bestoko.github.io/p/surface-linux/surface_hu4dfd7a842b0b08077966cbe869e7c3b7_55232_120x120_fill_q75_box_smart1.jpg","permalink":"https://bestoko.github.io/p/surface-linux/","title":"Surface设备在Arch Linux下驱动问题的解决方案"},{"content":"写在前面 在安装了基本的ArchLinux后，我们还需要一些配置、安装一些组件，来扩展系统功能，使其更符合我们日常使用习惯。\n配置网络 我们使用\nnmtui 选择Edit a connection，\n选择Add菜单，选择WI-FI，\nDevice 里输入 无线网卡的名字，SSID里输入WI-FI的名字，Security选择WPA \u0026amp;WPA2 Personal，OK-BACK-Quit退出。\n注：使用以下命令查看无线网卡名称\nip link show 重命名主机 vim /etc/hostname 保存想要的名字后退出。\n接下来把主机名、域名以及ip地址进行映射\nvim /etc/hosts 输入：(以下archlinux为上文所保存的主机名)\n127.0.0.1\tlocalhost ::1\tlocalhost 127.0.0.1 archlinux.localdomain\tarchlinux 设置系统时间 timedatectl set-timezone Asia/shanghai timedatectl set-ntp true 第二行设置为让本机时间与ntp同步。\n配置环境变量 vim /etc/skel/.bashrc 添加以下内容\nexport EDITOR=vim alias grep=\u0026#39;grep ==color=auto\u0026#39; alias egrep=\u0026#39;egrep ==color=auto\u0026#39; alias fgrep=\u0026#39;fgrep ==color=auto\u0026#39; [ ！ -e ~/.dircolors ] \u0026amp;\u0026amp; eval $(dircolors -p \u0026gt; ~/.dircolors) [ ！ -e /bin/dircolors ] \u0026amp;\u0026amp; eval $(dircolors -b \u0026gt; ~/.dircolors) 将bash shell 默认的文本编辑器设置为vim\n为grep，egrep，fgrep搜索出的内容添加颜色\n为看到的文件以及文件夹添加颜色\ncp -a . ~ 新建标准用户 useradd --create-home username passwd username usermod -aG wheel,users,storage,power,lp,adm,optical username 其中username替换为你所使用的名字，在创建时同时在/home目录下会创建一个与用户名同名的文件夹。家目录有一个别名是~，你可以在任何地方使用~来代替家目录路径。\n配置sudo visudo 将# %wheel ALL=(ALL) ALL 前的#号去除（去注释），保存退出。\n中英字体和图形界面的安装 安装Xorg Xorg是Linux下的一个著名的开源图形服务，我们的桌面环境需要Xorg的支持。\npacman -S xorg 显卡驱动的安装  \n参照如上表格安装相应的包，以Surface Pro 为例，需要安装intel的集成显卡驱动\npacman -S xf86-video-intel 安装字体 vim /etc/locales.gen 将en_US.UTF-8 UTF8 zh_CN.UTF-8 UTF8前的#删除（去注释），保存退出。\nvim /etc/locale.conf 输入\nLANG=en_US.UTF-8 如果想生成中文，就改成LANG=zh_TW.UTF-8\n接着生成字体\nlocale-gen 接下来安装英文字体\npacman -S ttf-dejavu ttf-droid ttf-hack ttf-font-awesome otf-font-awesome ttf-lato ttf-liberation ttf-linux-libertine ttf-opensans ttf-roboto ttf-ubuntu-font-family 再然后是安装中文字体\npacman -S ttf-hanom noto-fonts noto-fonts noto-fonts-extra not-fonts-emoji noto-fonts-cjk adobe-source-code-pro-fonts adobe-source-sans-fonts adobe-source-serif-fonts adobe-source-han-sans-cn-fonts adobe-source-han-sans-hk-fonts adobe-source-han-sans-tw-fonts adobe-source-han-serif-cn-fonts wqy-zenhei wqy-microhei 打开freetype2字体引擎\nvim /etc/profile.d/freetype2.sh 将最后一行去注释后保存退出。\n安装桌面环境 Linux下有很多桌面环境如Xfce、KDE(Plasma)、Gnome、Unity、Deepin等等，它们的外观、操作、设计理念等各方面都有所不同，这里我们选择Gnome为例，进行安装。\npacman -S gnome gnome-extra gdm 安装好了桌面环境包以后，我们需要安装一个图形化的桌面管理器来帮助我们登录并且选择我们使用的桌面环境，这里我使用上面的gdm\nsystemctl enable gdm.service 安装声音以及打印机系统 pacman -S alsa-utils pulseaudio pulseaudio-bluetooth cups 清楚安装缓存以及无用源 pacman -Scc 接着重启即可进入Gnome桌面\n小结 至此，ArchLinux基本安装与必要设置和图形界面都已经安装完毕。\n","date":"2021-12-15T00:00:00Z","image":"https://bestoko.github.io/p/archinstallextra/ArchLinux_hu13d81b556f6c7780a085a162084854bc_14536_120x120_fill_q75_box_smart1.jpg","permalink":"https://bestoko.github.io/p/archinstallextra/","title":"Arch Linux安装备忘录（二）"},{"content":"写在前面 安装Arch最好最全面的教程就是官方的 Installation guide。但是Wiki上的介绍更偏向文档，而不是新手习惯的那种按步骤编排的教程，加上中文Wiki的翻译往往落后于英文版，缺乏预备Linux知识的新手经常无从下手。\n笔者也是初学者，本篇文章仅作为自己在Surface Pro 2017从0开始安装配置Arch的记录。\n安装准备 磁盘准备 我们需要准备一块有空闲区域（没有被分区）的磁盘留给系统的安装。笔者只准备安装Arch单系统，因此在PE里用磁盘管理工具把Surface的磁盘0各个分区全部删除。你也可以在Windows下找到磁盘管理，自行划分一个区域留给安装使用。\n安装介质 https://www.archlinux.org/download/ 建议从下面的中国镜像下载iso文件\nhttps://rufus.ie/ 我们用Rufus来制作引导盘，此步需要用到一个空闲U盘。需要注意的是写入方式选择DD，分区类型选择GPT而非默认的MBR。\n设置启动顺序 接下来需要进入个人电脑的BIOS里把制作的U盘启动设置为第一位，笔者的Surface额外需要先关闭security boot，不同电脑进入BIOS的按键略有不同，Surface是开机键和音量+键，其他型号电脑请查阅搜索引擎。\n安装过程 正确设置好启动顺序后，启动时会看到ArchLinux的界面，按Enter键选择 Boot Arch Linux ，等待加载完成后会进入一个有命令提示符的界面。我们接下来将在这个界面执行一系列命令来讲Arch安装到之前准备的磁盘上。\n*网络连接 Arch的安装需要联网，如果你使用的是有线连接，可以跳过此部分，笔者这里使用无线连接继续安装。\n输入\niwctl 进入iwd模式，输入\ndevice list 查看你的网卡名字，这里假设是wlan0，输入\nstation wlan0 scan 检查扫描网络，输入\nstation wlan0 get-networks 查看网络名字，假设名字叫XXX，输入\nstation wlan0 connect XXX 接着输入密码（如果有密码的话），输入\nexit 退出iwd模式\n我们可以用ping命令来检验下是否连接成功\nping -c 4 baidu.com 接下来我们需要让安装介质里的数据库保持与官方一致的最新版本，因此需要同步一下，在此之前，我们可以配置下最新的镜像来保证下载速度。\nreflector --country China --age 24 --sort rate --portocol https --save /etc/pacman.d/mirrorlist  country 限定国家 age 24 限定下更新时间为24小时内的源 portocol https 选择https协议更安全  执行完毕后，可以用vim查看\nvim /etc/pacman.d/mirrorlist 磁盘分区 检查磁盘\nlsblk 用gdisk命令进行分区\ngdisk /dev/nvme0n1 其中nvme01 为你之前准备的磁盘。\n一路默认回车到Last sector 部分，因为我们准备用作启动分区，准备分配512M，所以输入+512M回车，接着输入分区编号ef00。这样第一个分区完成，接着第二个分区笔者分配了+235G，并使用默认的分区编号8300（Linux filesystem），最后剩下2G左右空间一路默认，分区编号输入8200（Linux swap）。确认无误后，w保存quit退出。\n接着格式化我们的三个分区，将nvme01p1格式化为vfat\nmkfs.vfat /dev/nvme01p1 将nvme01p2格式化为ext4或者xfs（推荐）\nmkfs.xfs /dev/nvme01p2 最后\nmkswap /dev/nvme01p3 挂载分区 mount /dev/nvme01p2 /mnt mkdir -p /mnt/boot/efi mount /dev/nvme01p1 /mnt/boot/efi swapon /dev/nvme01p3 安装基本包 pacstrap /mnt base base-devel linux linux-firmware linux-headers vim bash-completion 配置Fstab genfstab -U /mnt \u0026gt;\u0026gt; /mnt/etc/fstab cat /mnt/etc/fstab 确认下是否挂载无误\nchroot  Chroot意为Change root，相当于把操纵权交给我们新安装（或已经存在）的Linux系统，执行了这步以后，我们的操作都相当于在磁盘上新装的系统中进行。\n arch-chroot /mnt 安装必须软件包 现在我们已经Chroot到了新的系统中，只有一些最基本的包（组件），这时候我们就需要自己安装新的包。ArchLinux有非常强大的包管理工具pacman，大部分情况下，一行命令就可以搞定包与依赖的问题。\n安装包的命令格式为pacman -S 包名，pacman会自动检查这个包所需要的其他包（即为依赖）并一起装上。下面我们就通过pacman来安装一些包，这些包在之后会用上，在这里先提前装好。\n执行如下命令（注意大小写，大小写错误会导致包无法找到）：\npacman -S grub efibootmgr efivar networkmanager intel-ucode AMD用户请将intel-ucode替换成amd-ucode\n安装Bootloader 部署grub\ngrub-install /dev/nvme01 修改配置\nvim /etc/default/grub 将GRUB_TIMEOUT=5改成GRUB_TIMEOUT=2\n将GRUB_CMDLINE_LINUX_DEFAULT=\u0026quot;loglevel=3 quiet\u0026quot; 的quiet字段删除，这样登录的时候会有日志，如果出现错误可以查看日志文件。\n接着将GRUB_GFXMODE=auto修改为你的分辨率，以我的surface为例，改为GRUB_GFXMODE=2736x1824\n接着生成grub的配置文件\ngrub-mkconfig -o /boot/grub/grub.cfg 设置NetworkManager开机自动启动 systemctl enable NetworkManager 为root用户设置密码 passwd 卸载分区 拔除介质 umount /mnt/boot/efi umount /mnt 拔除介质重新启动\nreboot 小结 至此，我们成功安装了ArchLinux，然而此时系统处于非常精简的状态，距离日常使用还需要一些配置，安装一些需要的组件，下一部分我们将安装图形界面、配置显卡驱动、安装桌面环境\u0026hellip;.以及一些实用软件包。\n","date":"2021-12-14T00:00:00Z","image":"https://bestoko.github.io/p/archinstall/ArchLinux_hu13d81b556f6c7780a085a162084854bc_14536_120x120_fill_q75_box_smart1.jpg","permalink":"https://bestoko.github.io/p/archinstall/","title":"Arch Linux安装备忘录（一）"},{"content":"准备工作   解锁Bootloader且打开USB调试的一加8\n  氢OS Android11 Rom包\n  Payload Dumber\n  platform-tools\n打包下载： pan.baidu.com/s/1afSr1snXan4LoBLX9l0Urg 【pcge】\n  刷入Magisk 制作magisk_patched.img   将官方包内的payload.bin 解压并放入Payload Dumber 的payload_input目录\n  打开payload_dumper.exe（看到boot解压出来就可以关闭了）\n  打开payload_output目录，将解压出的boot.img复制到手机根目录\n  下载并安装Magisk最新版本 (https://github.com/topjohnwu/Magisk/releases)\n选择安装Magisk-选择并修补一个文件，选中放在根目录的boot.img ，等待修补完成\n  将手机download目录下的修补完成的magisk_patched.img复制到电脑\n  工具刷入mgisk_patched.img   将mgisk_patched.img放入 platform-tools 目录下\n  运行\n打开CMD命令行.bat  adb reboot bootloader fastboot flash boot_a magisk_patched.img fastboot flash boot_b magisk_patched.img fastboot reboot    刷入EdXposed  刷入Riru - Core模块 刷入Riru - EdXposed(YAHFA) 或Riru - EdXposed(SandHook)模块 安装最新的Edxposed Manager  总结与注意事项   制作mgisk_patched.img时要用最新的 v8.0.x版本，不能使用以往的v21.0版本\n  刷写mgisk_patched.img时 a/b分区都要\n  如果因刷入不兼容的模块导致无法开机，可以尝试\n卸载全部magisk模块\n adb shell magisk --remove-modules adb reboot     op8info \n op8magisk1 \n op8magisk2 \n op8edxposed \n","date":"2020-10-28T00:00:00Z","image":"https://bestoko.github.io/p/oneplus8/onepluslogo_hu7b2083ec43cbfc8c8606b4db91f24e67_30881_120x120_fill_q75_box_smart1.jpg","permalink":"https://bestoko.github.io/p/oneplus8/","title":"一加8的Android 11 折腾指南"},{"content":"​\t最近刚开始刷Leetcode，第一道Hard题就难倒了我。题解里有位大神的算法很巧妙，我很容易就理解了，在此做个记录。\n 题目链接：https://leetcode-cn.com/problems/median-of-two-sorted-arrays/\n题解链接：https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/4-xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-shu/\n 题目  给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。\n请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。\n你可以假设 nums1 和 nums2 不会同时为空。\n示例 1:\n nums1 = [1, 3] nums2 = [2]\n 则中位数是 2.0 示例 2:\n nums1 = [1, 2] nums2 = [3, 4]\n 则中位数是 (2 + 3)/2 = 2.5\n 分析 首先要理解中位数  中位数（Median）又称中值，统计学中的专有名词，是按顺序排列的一组数据中居于中间位置的数，代表一个样本、种群或概率分布中的一个数值，其可将数值集合划分为相等的上下两部分。对于有限的数集，可以通过把所有观察值高低排序后找出正中间的一个作为中位数。如果观察值有偶数个，通常取最中间的两个数值的平均数作为中位数。\n  [2 3 5] 中位数是3\n[1 4 7 9] 中位数是(4+7)/2=5.5\n 割(Cut)的概念   通过切一刀，可以把有序数组分成左右两个部分，切的那一刀就被称为割(Cut)。\n  割(Cut)的左右会有两个元素，分别是左边最大值和右边最小值。\n  定义LMax= Max(LeftPart) RMin = Min(RightPart) //由小到大的有序数组\n  割可以割在2个数中间，也可以割在1个数上，如果割在一个数上，那么这个数既属于左边，也属于右边\n   奇数组: [2 3 5] 对应的中位数为3，假定割(Cut)在3上，我们可以把3分为2个： [2（3/3） 5]\n因此LMax=3, RMin=3\n偶数组: [1 4 7 9] 对应的中位数为 (4 + 7) /2 = 5.5,假定割(Cut)在4和7之间： [1 （4/7）9]\n因此LMax=4, RMin=7\n 割和第k个元素 一个数组 对于有序数组A，如果在k的位置割一下，容易得出LMax = RMin = A[k]\n两个数组 将两个数组合成一个有序数组时，第k位的元素\n 我们设: Ci为第 i个数组的割\nLMaxi为第i个数组割后的左元素i\nRMini为第i个数组割后的右元素\n    Leftpart Ci Rightpart     a1,a2,\u0026hellip;,ai / ai+1,ai+2,\u0026hellip;,am   b1,b2,\u0026hellip;,bj / bj+1,bj+2,\u0026hellip;,bn    首先，因为数组是有序的，所以LMax1 \u0026lt;= RMin1，LMax2 \u0026lt;= RMin2 //割在某个数上时左右相等\n其次，如果让LMax1 \u0026lt;= RMin2，LMax2 \u0026lt;= RMin1 呢？\n这表示左半边全部小于右半边。如果让左边的元素个数相加刚好为k，那第k个元素就是max(LMax1, Lmax2)，也就是合并后有序数组左边k个元素的最大值。\n那么如果LMax1 \u0026gt; RMin2，说明数组1的左边元素太多，我们把C1减小，C2 = k - C1相应地增大。LMax2 \u0026gt; RMin1同理，把C2减小，C1 = k - C2也就相应地增大。\n举例（设k = 3）  [2 3 5] [1 4 7 9]\n 设C1 = 1，则 C2 = k - C1 = 2 割后：\n [2 3 / 5] [1 / 4 7 9]\n 此时，LMax1 = 3, RMin1 = 5, LMax2 = 1, RMin2 = 4,\n满足 LMax1 \u0026lt; RMin2 且 LMax2 \u0026lt; RMin1 ，\n所以第3个元素为max(LMax1, LMax2) = 3\n两个数组合并后的长度问题 （本篇题解巧妙所在）  两个数组的最大问题是，它们合并后，m+n总数可能为奇, 也可能为偶，所以我们得想法让m+n总是为偶数\n通过虚拟加入‘#’，我们让m转换成2m+1 ，n转换成2n+1, 两数之和就变成了2m+2n+2，恒为偶数。\n注意是虚拟加，其实根本没这一步，通过下面的转换，我们可以保证虚拟加后每个元素跟原来的元素一一对应\n    before len after len     [1 4 7 9] 4 [# 1 # 4 # 7 # 9] 9   [2 3 5] 3 [# 2 # 3 # 5 ] 7    这么虚拟加后，每个位置可以通过/2得到原来元素的位置：\n比如 2，原来在0位，现在是1位，1/2=0\n比如 3，原来在1位，现在是3位，3/2=1\n比如 5，原来在2位，现在是5位，5/2=2\n比如 9，原来在3位，现在是7位，7/2=3\n而对于割(Cut)，如果割在‘#’上等于割在2个元素之间，割在数字上等于把数字划到2个部分，总是有以下成立：\n LMaxi = (Ci-1)/2 位置上的元素 RMini = Ci/2 位置上的元素\n 例如：\n割在3上，C = 3，LMax=a[(3-1)/2]=A[1]，RMin=a[3/2] =A[1]，刚好都是3的位置！\n割在4/7之间‘#’，C = 4，LMax=A[(4-1)/2]=A[1]=4 ，RMin=A[4/2]=A[2]=7\n剩下的事情就好办了，把2个数组看做一个虚拟的数组A，A有2m+2n+2个元素，割在m+n+1处，所以我们只需找到m+n+1位置的元素和m+n+2位置的元素就行了。\n左边：A[m+n+1] = Max(LMax1,LMax2)\n右边：A[m+n+2] = Min(RMin1,RMin2)\n==\u0026gt;Mid = (A[m+n+1]+A[m+n+2])/2 = (Max(LMax1,LMax2) + Min(RMin1,RMin2) )/2\n最快的割(Cut)是使用二分法，有2个数组，我们对哪个做二分呢？ 根据之前的分析，我们知道了，只要C1或C2确定，另外一个也就确定了。这里，为了效率，我们肯定是选长度较短的做二分，假设为C1。\nLMax1\u0026gt;RMin2，把C1减小，C2增大。—\u0026gt; C1向左二分\nLMax2\u0026gt;RMin1，把C1增大，C2减小。—\u0026gt; C1向右二分\n如果C1或C2已经到头了怎么办？ 这种情况出现在：如果有个数组完全小于或大于中值。假定n\u0026lt;m, 可能有4种情况：\nC1 = 0 —— 数组1整体都在右边了，所以都比中值大，中值在数组2中，简单的说就是数组1割后的左边是空了，所以我们可以假定LMax1 = INT_MIN\nC1 =2n —— 数组1整体都在左边了，所以都比中值小，中值在数组2中 ，简单的说就是数组1割后的右边是空了，所以我们可以假定RMin1= INT_MAX，来保证LMax2 \u0026lt; RMin1恒成立\nC2 = 0 —— 数组2整体在右边了，所以都比中值大，中值在数组1中 ，简单的说就是数组2割后的左边是空了，所以我们可以假定LMax2 = INT_MIN C2 = 2m —— 数组2整体在左边了，所以都比中值小，中值在数组1中, 简单的说就是数组2割后的右边是空了，为了让LMax1 \u0026lt; RMin2 恒成立，我们可以假定RMin2 = INT_MAX\n代码 #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;vector\u0026gt;using namespace std; #define max(a,b) (((a) \u0026gt; (b)) ? (a) : (b)) #define min(a,b) (((a) \u0026lt; (b)) ? (a) : (b))  class Solution { public: double findMedianSortedArrays(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2) { int n = nums1.size(); int m = nums2.size(); if (n \u0026gt; m) //保证数组1一定最短 \t{ return findMedianSortedArrays(nums2, nums1); } // Ci 为第i个数组的割,比如C1为2时表示第1个数组只有2个元素。LMaxi为第i个数组割后的左元素。RMini为第i个数组割后的右元素。 \tint LMax1, LMax2, RMin1, RMin2, c1, c2, lo = 0, hi = 2 * n; //我们目前是虚拟加了\u0026#39;#\u0026#39;所以数组1是2*n长度 \twhile (lo \u0026lt;= hi) //二分 \t{ c1 = (lo + hi) / 2; //c1是二分的结果 \tc2 = m + n - c1; LMax1 = (c1 == 0) ? INT_MIN : nums1[(c1 - 1) / 2]; RMin1 = (c1 == 2 * n) ? INT_MAX : nums1[c1 / 2]; LMax2 = (c2 == 0) ? INT_MIN : nums2[(c2 - 1) / 2]; RMin2 = (c2 == 2 * m) ? INT_MAX : nums2[c2 / 2]; if (LMax1 \u0026gt; RMin2) hi = c1 - 1; else if (LMax2 \u0026gt; RMin1) lo = c1 + 1; else break; } return (max(LMax1, LMax2) + min(RMin1, RMin2)) / 2.0; } }; int main(int argc, char *argv[]) { vector\u0026lt;int\u0026gt; nums1 = { 2,3, 5 }; vector\u0026lt;int\u0026gt; nums2 = { 1,4,7, 9 }; Solution solution; double ret = solution.findMedianSortedArrays(nums1, nums2); return 0; } ","date":"2020-04-10T00:00:00Z","image":"https://bestoko.github.io/p/leetcode004/leetcode_huc40bc8c685b4e68ad6cc20881a359f28_10178_120x120_fill_q75_box_smart1.jpg","permalink":"https://bestoko.github.io/p/leetcode004/","title":"寻找两个有序数组的中位数"},{"content":"前情提要 为什么要水这么一篇文章\n在把switch借给朋友玩的这段时间，我把目光投向了吃灰已久的3ds\u0026hellip;.\n我想要在实机上游玩gba游戏，但是3ds上的模拟器又有各种各样的兼容性问题，达不到eshop里VC金银流畅的游玩体验；宣称能游玩GBA的DSTWO PLUS烧录卡早已停产，某宝/闲鱼的价格居高不下\u0026hellip;经过一番摸索，我找到了可能是现今最好的解决方案。\n准备工作   一台BOOT9STARP(B9S)破解的3ds\n参考3ds破解手册或者一只火狐大佬整理的教程(推荐)\n嫌麻烦的同学可以交给热心摊主处理\n  Ultimate GBA VC Injector for 3DS\n  汉化版下载链接\n  你想要在3ds上运行的GBA游戏ROM文件\n这里以漆黑的魅影为例（很棒的GBA宝可梦改版，我一直想在实机上玩）\n  GBA 转CIA  打开软件并导入下载好的.gba文件，ROM大小和存档类型会自动确认(汉化版ROM往往是数据库未找到该游戏，请确保选择的正确无误以免影响存档)   gba2cia1 \n gba2cia2 \n 填写要转换的VC图标和名称(因为3ds字库的原因建议不要使用中文XD)，设置3D横幅(就是选中这个游戏时3ds上屏的画面)\n gba2cia3 \n gba2cia4 \n  设置VC参数并导出CIA文件(注意当转换多个.cia文件时，确保每个文件的产品代码及项目ID都不一样)\n gba2cia5 \n  在3ds上安装转换好的.cia文件\n  关于如何B9S如何安装cia文件这里不再赘述(实在懒得截图了)\n gba2cia6 \n大功告成~\n备注事项  据说部分老款3ds对这种方式转换的.cia支持不好，会出现黑屏情况(我的美版老小三反正测试是没问题啦) 港版不支持港版不支持港版不支持 存档类型一定要设置正确  ","date":"2020-03-30T00:00:00Z","image":"https://bestoko.github.io/p/gba2cia/3ds_hu4bf660668473ef4591016bcd087f3f0c_132271_120x120_fill_q75_box_smart1.jpg","permalink":"https://bestoko.github.io/p/gba2cia/","title":"GBA文件转CIA文件，在3ds上游玩GBA游戏的解决方案"},{"content":" Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。\nGit 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。\nGit 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。\n  learnGit \n常用指令 $ git init # 在当前目录新建一个 Git 代码库 $ git clone [url] # 下载一个项目和它的整个代码历史 $ git config --list # 显示当前的 Git 配置 $ git config -e [--global] # 编辑 Git 配置文件 $ git add # 添加指定文件到暂存区 $ git rm # 删除工作区文件，并且将这次删除放入暂存区 $ git commit -m [message] # 提交暂存区到仓库区 $ git commit -a # 提交工作区自上次 commit 之后的变化，直接到仓库区 $ git commit --amend -m [message] # 使用一次新的 commit，替代上一次提交 如果代码没有任何新变化，则用来改写上一次 commit 的提交信息 $ git commit --amend [file1] [file2] ... # 重做上一次 commit，并包括指定文件的新变化 # 分支相关 $ git branch # 列出所有本地分支 $ git branch -r # 列出所有远程分支 $ git branch [branch-name] # 新建一个分支，但依然停留在当前分支 $ git checkout [branch-name] # 切换到指定分支，并更新工作区 $ git checkout -b [branch] # 新建一个分支，并切换到该分支 $ git branch [branch] [commit] # 新建一个分支，指向指定 commit $ git checkout -b [branch] [tag] # 新建一个分支，指向某个 tag $ git branch --track [branch] [remote-branch] # 新建一个分支，与指定的远程分支建立追踪关系 $ git branch --set-upstream [branch] [remote-branch] # 建立追踪关系，在现有分支与指定的远程分支之间 $ git merge [branch] # 合并指定分支到当前分支 $ git cherry-pick [commit] # 选择一个 commit，合并进当前分支 $ git branch -d [branch-name] # 删除分支 $ git push origin --delete [branch-name] # 删除远程分支 $ git branch -dr [remote/branch] # 删除远程分支 # 标签 $ git tag # 列出所有 tag $ git tag [tag] # 新建一个 tag 在当前 commit $ git tag [tag] [commit] # 新建一个 tag 在指定 commit $ git show [tag] # 查看 tag 信息 $ git push [remote] [tag] # 提交指定 tag $ git push [remote] --tags # 提交所有 tag # 查看 $ git status # 显示有变更的文件 $ git log # 显示当前分支的版本历史 $ git log --stat # 显示 commit 历史，以及每次 commit 发生变更的文件 $ git log --follow [file] # 显示某个文件的版本历史，包括文件改名 $ git log -p [file] # 显示指定文件相关的每一次 diff $ git blame [file] # 显示指定文件是什么人在什么时间修改过 $ git diff # 显示暂存区和工作区的差异 $ git diff --cached [file] # 显示暂存区和上一个 commit 的差异 $ git diff HEAD # 显示工作区与当前分支最新 commit 之间的差异 $ git diff [first-branch]...[second-branch] # 显示两次提交之间的差异 $ git show [commit] # 显示某次提交的元数据和内容变化 $ git show --name-only [commit] # 显示某次提交发生变化的文件 $ git show [commit]:[filename] # 显示某次提交时，某个文件的内容 $ git reflog # 显示当前分支的最近几次提交 # 远程 $ git fetch [remote] # 下载远程仓库的所有变动 $ git remote -v # 显示所有远程仓库 $ git remote show [remote] # 显示某个远程仓库的信息 $ git remote add [shortname] [url] # 增加一个新的远程仓库，并命名 $ git pull [remote] [branch] # 取回远程仓库的变化，并与本地分支合并 $ git push [remote] [branch] # 上传本地指定分支到远程仓库 $ git push [remote] --force # 强行推送当前分支到远程仓库，即使有冲突 $ git push [remote] --all # 推送所有分支到远程仓库 # 撤销 $ git checkout [file] # 恢复暂存区的指定文件到工作区 $ git checkout [commit] [file] # 恢复某个 commit 的指定文件到工作区 $ git checkout . # 恢复上一个 commit 的所有文件到工作区 $ git reset [file] # 重置暂存区的指定文件，与上一次 commit 保持一致，但工作区不变 $ git reset --hard # 重置暂存区与工作区，与上一次 commit 保持一致 $ git reset [commit] # 重置当前分支的指针为指定 commit，同时重置暂存区，但工作区不变 $ git reset --hard [commit] # 重置当前分支的 HEAD 为指定 commit，同时重置暂存区和工作区，与指定 commit 一致 $ git reset --keep [commit] # 重置当前 HEAD 为指定 commit，但保持暂存区和工作区不变 $ git revert [commit] # 新建一个 commit，用来撤销指定 commit，后者的所有变化都将被前者抵消，并且应用到当前分支 学习资源  git - 简明指南 pro git（中文版） Git 教程 Git 参考手册 Git 指南 Learn Git Branching  ","date":"2020-03-23T00:00:00Z","image":"https://bestoko.github.io/p/gitnotes/git_logo_hu0871f2e332734283fcd708b643f05707_22105_120x120_fill_q75_box_smart1.jpg","permalink":"https://bestoko.github.io/p/gitnotes/","title":"Git学习笔记"},{"content":" Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。\n 以下是Markdown的基础语法\n~~删除线~~ *斜体* _斜体第二种方法_ **加粗** __加粗的第二种方法__ ___粗斜体___ 两个enter是换行，或者用\u0026lt;/br\u0026gt;标签表示换行 用一行的=或者-表示一级标题和二级标题。如： 一级标题 ======= 二级标题 -------- 也可以在前面加上一到六个#表示标题的1级到6级，标题前加一个空格。如： # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题  无序列表：在前面加上 * 或者 + 或者 - 然后加个空格： * ABC * DEF * GHI + JKL + MNO + PQR - STU - VWX - YZZ 有序列表：数字+英文句点+空格。如下： 1. 呵呵 2. 哈哈 3. 嘿嘿 4. 哼哼 \u0026amp;lt; // 会显示为”\u0026lt;“ \u0026amp;amp; // 会显示为”\u0026amp;“：在 href 属性里面，必须将 \u0026amp; 转变为 \u0026amp;amp; \\. // 为了防止产生\u0026#34;1.\u0026#34;变为有序列表，则可以写成\u0026#34;1\\.\u0026#34; * _ // 如果 * 和 _ 两边都有空白的话，它们就只会被当成普通的符号。 \u0026gt;只在整个段落的第一行最前面加上大于号可以显示引用（此时出现引用形式，并且为斜体）。但是引言内如果要断行，那个空行也必须在前面加上大于号。就像下面写的酱紫： \u0026gt;\u0026gt;区块引言也可以有级别，在前面加上不同数量的大于号即可。比如说这就是一个二级引言。 \u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt;这是一个三级引言。格式会显示为字体更小了。 建立分割线的方法有： * * * ***** - - - ------------------- 超级链接：[超级链接显示的文字](超级链接的网址，可以是绝对路径、相对路径) 也支持HTML格式的超级链接\u0026lt;a href=\u0026#34;https://www.baidu.com/\u0026#34;\u0026gt;百度\u0026lt;/a\u0026gt; 如果要标记一小段行内程序代码，可以用反引号把它包起来，像这样： Use the `printf()` function. 插入图片：![图片的替换文字](图片的地址或路径) ![风景区图片](/Snip20160202_227.png) Email邮件： \u0026lt;123456789@qq.com\u0026gt; 锚点：(能够链接到某个一级标题) [想要显示的名称](#锚点的名称) ","date":"2020-03-12T00:00:00Z","image":"https://bestoko.github.io/p/markdwonnotes/markdown_hu593b1bacfa1a4c5df7b3aa16ecfb0c28_37213_120x120_fill_q75_box_smart1.jpg","permalink":"https://bestoko.github.io/p/markdwonnotes/","title":"Markdown学习笔记"}]