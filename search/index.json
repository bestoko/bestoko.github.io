[{"content":"你也许在很多书籍影视或者游戏中早已接触过无线电，但是真正亲身在现实中拿起对讲机与别人通联，则另有一番乐趣。\n我大概是在去年在某硬件群内了解到业余无线电以及考证相关的内容，而最近又被一个介绍《我们生活在南京》这本科幻小说的视频勾起了兴趣，赶上南京2023年度第一次业余无线电操作能力考试，3.18考完试，3月24日实体双证都拿到手了，也算是比较快的“速通”了，在此记录一下其中的坑点与技巧。\n概览 首先要知道是，想要合法通联，你需要准备的东西有\n业余无线电操作证 符合国家技术标准的无线电发射设备 无线电台执照与呼号 其中，3可以在准备好1和2的情况下，填写 《业余无线电台技术资料申报表》与 《业余无线电台设置(变更)申请表》向当地工信部申请获得，而2的话，一般只需注意买的设备要有核准码即可（可在智谱app查询），因此重点在于通过考试拿到业余无线电操作证。\n而业余无线电操作证分为ABC三个等级，A级最低，C级最高，等级高低影响操作员获准使用的频段和最大功率。操作证只能按A，B，C顺序依次取得。我这次取得的就是A级，购买的设备是泉盛的 UV-K5（性价比很高，推荐入门使用）\n报名 如果你只对收讯感兴趣，对通联并不感冒，你可以考虑玩软件无线电或者面向无线电爱好者的收音机（例如德生）,并不需要报名考试。\n报名方式分为两种, 这里我选择的是手机APP的方式 小技巧：如果近期没有你所在城市的场次，你可以随便选择一场考试报名，将信息全部填写完成，所需照片和证件上传完成点击保存。这样当你需要报名的生活就可以省去重复填写资料的时间。 ！！某种意义上说，A类考试最难的就是抢到报名资格XD\n（1）网页报名：登录CRAC官网www.crac.org.cn，页面底部右下方选择“能力验证”，选择“考生入口”，进入“业余无线电台操作技术能力验证考核报名及信息管理系统”进行注册报名。\n（2）手机APP报名：应用市场下载“智谱”APP，从手机下方的“特别入口”进入，点击“考试报名”，选择相应的考试场次进行报名。\n考试 试题范围为中国无线电协会业余无线电工作委员会（CRAC）公布的题库。\n你可以选择按照官方的指南在“业余无线电台操作技术能力验证及信息管理系统”的“资料下载”模块，下载安装“模拟考试软件”或TXT格式题库包，或者在“智谱”APP的“业余无线电移动信息平台”，进行复习和模拟考试。当然也可以像我一样使用更方便的微信小程序刷题，这里我推荐的是业余无线电工具集 或者 HAM模拟考试\n当然，如果嫌单纯的刷题太过枯燥，需要一些记忆方法的话，这里推荐长沙一位前辈（B站@长沙李折腾）的视频，里面有不少应试技巧与口诀，幽默诙谐容易记住。 考试当天一般都是只有一次机会，时间非常充裕，请务必认真答题不要浪费宝贵的报名资格\n设台 不同地区的规定不同，南京这边考试现场为考试合格考生提供25W以下业余无线电台验机服务，当然也可以选择改日单独送去验机，具体看当地规定。需要注意的是一定要从正规渠道购买有核准码的机型，群里见到有因为买到问题批次的机器没有通过验机的朋友，验机现场也有因为机身上没有核准码标签而差点被拒的朋友。\n一切准备妥当后，到设台当地工信部提交好证明等待即可。首次设台时，管局会给分配一个全球唯一的呼号，这个呼号会伴随你的整个业余无线电生涯。（呼号一般不可自选，但据考试群友反馈某些地方线下办理允许自选一位，有想法的可以线下去问）\n最后 希望你能够玩得开心，这里是BD4UTT 期待与您空中相遇 73\n","date":"2023-03-25T23:31:05+08:00","image":"https://bestoko.cc/p/amateurradio/wuxiandian_hu5666d9c67620149a5fbab0a1d6753a3e_73349_120x120_fill_q75_box_smart1.jpg","permalink":"https://bestoko.cc/p/amateurradio/","title":"业余无线电拿证(A类)\u0026设台速通指北"},{"content":"OpenAI家的chatGPT 最近的火热不必多说，还有很多墙内的小伙伴由于种种原因不能很方便地使用，正巧我最近在折腾在 NAS 上部署 QQ 机器人，找到一个很方便的将 ChatGPT 接入 QQ 机器人的插件。\n事前准备 你需要准备：\nkoishi koishi是一个高性能的机器人服务，你可以在官网任选一个合适的方式部署（Windows/macOS/Linux/Android/容器） chatGPT API key 你可以通过 https://platform.openai.com/account/api-keys 获取 （注册openAI 账号的方法不在本文介绍 事实上随便找个国外的接码平台就可以了） 一个 QQ 小号，等级尽可能高一点以免风控 （koishi 事实上支持包括 QQ/discord/telegram/kook/feishu等的部署） 下面，我将在我自己的 NAS 上通过 koishi 容器的方式进行操作，我的 NAS 系统是 unraid 6.11.5 （ Linux 内核 5.19.17）\n操作部署 unraid docker 部署 koishi 也可通过 unraid 的 docker 配置，具体如下\n在 unraid 上使用推荐后面一种方法，方便设置图标（看着更舒服一点） 效果如下:\nkoishi 以及 chatGPT 插件的配置 按照你的 QQ 小号设置 adapter-onebot ，设置完后右上角找到启用插件。需要注意的是 protocol 需要选择 ws-reverse。\n接着去插件市场安装 koishi_chatGPT 插件根据提示加载 cache 服务并配置 apiKey ：\napikey 可以在 https://platform.openai.com/account/api-keys 获取。\n然后启用插件\nEnjoy it 接下来 你就可以和群友们一起好好提(调)问(教) ChatGPT 了 XD\n20220305补充：\n请尽可能的在可信任的朋友的群里使用，我的群友们疑似因为提问了太多不能碰的滑梯，两天用完了免费的 18$ 余额，第三天群也炸了 \u0026hellip;\n","date":"2023-03-01T21:30:00+08:00","image":"https://bestoko.cc/p/koishi-chatgpt/KoishiJS_hu908b63fc8e23b9e0aa4a716540e4f558_46845_120x120_fill_box_smart1_3.png","permalink":"https://bestoko.cc/p/koishi-chatgpt/","title":"从零开始拥有一个属于自己的 ChatGPT QQ机器人"},{"content":"问题 ​\t最近我想用 Windows11 WSL2 上的 Ubuntu 20.04 来折腾我写博客用的 hugo 环境，发现执行 hugo server后并不能在主机的 localhost:1313 成功预览（尽管微软的文档里说的是可以:sweat:）\n一番折腾后找到了解决方法，在 WSL2 别的 Linux 发行版应该也适用\n解决方法 首先获取 WSL 2 Ubuntu host 的 ip 地址\n1 ipconfig 我这里获取到的是 172.20.3.63\n然后在 hugo 目录下执行\n1 hugo server --bind 172.20.3.63 --baseURL=http://172.20.3.63 接着 Windows 主机的浏览器就可以通过访问 172.20.3.63:1313 成功预览了\n","date":"2022-12-10T23:25:00+08:00","image":"https://bestoko.cc/p/hugo_wsl2/WSL2_hu32b6a15140d8ae5f7ebc669008341df4_780416_120x120_fill_box_smart1_3.png","permalink":"https://bestoko.cc/p/hugo_wsl2/","title":"Windows11 WSL2 下配置 hugo 环境踩坑 "},{"content":"将下面的代码保存为kernel.py, 加入可执行权限， 执行./kernel.py -i kernel_log -o kernel.txt , 打开kernel.txt 就可以看到（与android logcat -v time一样的）时间戳\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 import time import datetime import sys import getopt import os a_time = None s_second = None s_microsecone = None abs_time = 0.0 inputfile = None outputfile = None def usage(): print(\u0026#39;\u0026#39;\u0026#39;Help Information: -h, --help: Show help information -i, --inputfile: input file to parse -o, --outputfile: output fiel parsed \u0026#39;\u0026#39;\u0026#39;) def calc_delta(stream): global s_second global s_microsecond global a_time global outfile begin_index = None end_index = None delta_second = 0 delta_mircosecond = 0 delta_time = 0 d_time = None new_line = None if a_time ==None: print(\u0026#34;Can\u0026#39;t convert to android time\u0026#34;) exit(-1) for line in stream: if line: try: begin_index = line.index(\u0026#39;[\u0026#39;) end_index = line[begin_index+1:].index(\u0026#39;]\u0026#39;)+begin_index+1 time_string = line[begin_index + 1 :end_index] [d_second,d_microsecond] = time_string.split(\u0026#39;.\u0026#39;) delta_second = int(int(d_second) - int(s_second)) delta_microsecond = int(int(d_microsecond)-int(s_microsecond)) delta_time = datetime.timedelta(seconds=delta_second,microseconds=delta_microsecond) d_time = a_time + delta_time new_line = d_time.strftime(\u0026#34;%m-%d %H:%M:%S.%f\u0026#34;)+\u0026#39; \u0026#39; + line outputfile.write(new_line) except: outputfile.write(line) def get_atime(stream): global s_second global s_microsecond global a_time a_time_op = None begin_index = None end_index = None for line in stream: if line: a_time_op = line.find(\u0026#39;android time\u0026#39;) if a_time_op\u0026gt;=1: begin_index = line.index(\u0026#39;[\u0026#39;) end_index = line[begin_index+1:].index(\u0026#39;]\u0026#39;)+begin_index+1 date_string = line[a_time_op+13:].strip() abs_time = line[begin_index + 1 :end_index] [s_second,s_microsecond] = abs_time.split(\u0026#39;.\u0026#39;) a_time = datetime.datetime.strptime(date_string, \u0026#34;%Y-%m-%d %H:%M:%S.%f\u0026#34;) break def main(argv): global inputfile global outputfile inputpath = None outputpath = None try: opts, args = getopt.getopt(argv,\u0026#34;hi:o:\u0026#34;,[\u0026#34;help\u0026#34;,\u0026#34;inputfile=\u0026#34;,\u0026#34;outputfile=\u0026#34;]) except getopt.GetoptError: usage() sys.exit(2) for opt, arg in opts: if opt in (\u0026#34;-h\u0026#34;, \u0026#34;--help\u0026#34;): usage() sys.exit() if opt in (\u0026#34;-i\u0026#34;, \u0026#34;--inputfile\u0026#34;): inputpath = arg if opt in (\u0026#34;-o\u0026#34;, \u0026#34;outputfile\u0026#34;): outputpath = arg if inputpath == None: usage() sys.exit() if outputpath == None: outputpath = os.getcwd()+\u0026#34;/out.txt\u0026#34; inputfile = open(inputpath, \u0026#39;r\u0026#39;) outputfile = open(outputpath, \u0026#39;w\u0026#39;) get_atime(inputfile) inputfile.seek(0) calc_delta(inputfile) inputfile.close() outputfile.close() if __name__ == \u0026#34;__main__\u0026#34;: main(sys.argv[1:]) ","date":"2022-06-22T23:00:00+08:00","image":"https://bestoko.cc/p/kernellogaddtime/Linux-Kernel_hu21c158f85a972cfaee160413dea99c65_31915_120x120_fill_q75_box_smart1.jpg","permalink":"https://bestoko.cc/p/kernellogaddtime/","title":"为Android Kernel Log添加时间戳"},{"content":" Camera 相关模块 代码路径 CameraService frameworks/av/services/camera/libcameraservice/CameraService.cpp CameraHALServer mtkcam3/main/hal/service/service.cpp ICameraProvider mtkcam/main/hal/devicemgr/provider/2.4/CameraProviderImpl.cpp ICameraDevice mtkcam3/main/hal/device/3.x/device/CameraDevice3Impl.cpp ICameraDeviceSession mtkcam3/main/hal/device/3.x/device/CameraDevice3SessionImpl.cpp CameraDeviceManager mtkcam3/main/hal/devicemgr/base/CameraDeviceManagerBase.cpp AppStreamMgr mtkcam3/main/hal/device/3.x/app/AppStreamMgr.cpp PipelineModel mtkcam3/pipeline/model/PipelineModelImpl.cpp CameraSetting mtkcam/middleware/v3/pipeline/CameraSetting/CameraSettingMgr_Imp.cpp MetadataProvider mtkcam/utils/metastore/metadataprovider/MetadataProvider.cpp StreamBuffer mtkcam/pipeline/utils/streambuf/StreamBuffers.cpp Hardware Node mtkcam3/pipeline/hwnode/ FeaturePipe mtkcam3/feature/core/featurePipe/ Pipe Driver mtkcam/drv/src/isp/isp_6s/imageio/pipe Sensor Driver \u0026lt;kernel-x.xx\u0026gt;/drivers/misc/mediatek/imgsensor/src/ EEPROM Driver \u0026lt;kernel-x.xx\u0026gt;/drivers/misc/eeprom/eeprom.c ","date":"2022-06-15T20:00:00+08:00","image":"https://bestoko.cc/p/mtkcamerahal3modules/HAL3_hue5e7e530428368b457f54449a2a3928f_21495_120x120_fill_box_smart1_3.png","permalink":"https://bestoko.cc/p/mtkcamerahal3modules/","title":"MTK 平台 Camera HAL3 相关模块的代码路径"},{"content":"Ubuntu 20.04如果安装时默认选择英文，使用时会发现在浏览器或者 gedit 等界面上出现部分汉字显示不正常，比如“关”和“复”显示偏小，“门”字中间有一点，如下图：\n其实是因为 CJK 字体日语默认的优先级比较高，这些字显示的是日文字体，解决方法如下：\n1 vim /etc/fonts/conf.d/64-language-selector-prefer.conf 原文件内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE fontconfig SYSTEM \u0026#34;fonts.dtd\u0026#34;\u0026gt; \u0026lt;fontconfig\u0026gt; \u0026lt;alias\u0026gt; \u0026lt;family\u0026gt;sans-serif\u0026lt;/family\u0026gt; \u0026lt;prefer\u0026gt; \u0026lt;family\u0026gt;Noto Sans CJK JP\u0026lt;/family\u0026gt; \u0026lt;family\u0026gt;Noto Sans CJK KR\u0026lt;/family\u0026gt; \u0026lt;family\u0026gt;Noto Sans CJK SC\u0026lt;/family\u0026gt; \u0026lt;family\u0026gt;Noto Sans CJK TC\u0026lt;/family\u0026gt; \u0026lt;family\u0026gt;Noto Sans CJK HK\u0026lt;/family\u0026gt; \u0026lt;family\u0026gt;Lohit Devanagari\u0026lt;/family\u0026gt; \u0026lt;/prefer\u0026gt; \u0026lt;/alias\u0026gt; \u0026lt;alias\u0026gt; \u0026lt;family\u0026gt;serif\u0026lt;/family\u0026gt; \u0026lt;prefer\u0026gt; \u0026lt;family\u0026gt;Noto Serif CJK JP\u0026lt;/family\u0026gt; \u0026lt;family\u0026gt;Noto Serif CJK KR\u0026lt;/family\u0026gt; \u0026lt;family\u0026gt;Noto Serif CJK SC\u0026lt;/family\u0026gt; \u0026lt;family\u0026gt;Noto Serif CJK TC\u0026lt;/family\u0026gt; \u0026lt;family\u0026gt;Lohit Devanagari\u0026lt;/family\u0026gt; \u0026lt;/prefer\u0026gt; \u0026lt;/alias\u0026gt; \u0026lt;alias\u0026gt; \u0026lt;family\u0026gt;monospace\u0026lt;/family\u0026gt; \u0026lt;prefer\u0026gt; \u0026lt;family\u0026gt;Noto Sans Mono CJK JP\u0026lt;/family\u0026gt; \u0026lt;family\u0026gt;Noto Sans Mono CJK KR\u0026lt;/family\u0026gt; \u0026lt;family\u0026gt;Noto Sans Mono CJK SC\u0026lt;/family\u0026gt; \u0026lt;family\u0026gt;Noto Sans Mono CJK TC\u0026lt;/family\u0026gt; \u0026lt;family\u0026gt;Noto Sans Mono CJK HK\u0026lt;/family\u0026gt; \u0026lt;/prefer\u0026gt; \u0026lt;/alias\u0026gt; \u0026lt;/fontconfig\u0026gt; 更改后内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE fontconfig SYSTEM \u0026#34;fonts.dtd\u0026#34;\u0026gt; \u0026lt;fontconfig\u0026gt; \u0026lt;alias\u0026gt; \u0026lt;family\u0026gt;sans-serif\u0026lt;/family\u0026gt; \u0026lt;prefer\u0026gt; \u0026lt;family\u0026gt;Noto Sans CJK SC\u0026lt;/family\u0026gt; \u0026lt;family\u0026gt;Noto Sans CJK TC\u0026lt;/family\u0026gt; \u0026lt;family\u0026gt;Noto Sans CJK HK\u0026lt;/family\u0026gt; \u0026lt;family\u0026gt;Noto Sans CJK JP\u0026lt;/family\u0026gt; \u0026lt;family\u0026gt;Noto Sans CJK KR\u0026lt;/family\u0026gt; \u0026lt;family\u0026gt;Lohit Devanagari\u0026lt;/family\u0026gt; \u0026lt;/prefer\u0026gt; \u0026lt;/alias\u0026gt; \u0026lt;alias\u0026gt; \u0026lt;family\u0026gt;serif\u0026lt;/family\u0026gt; \u0026lt;prefer\u0026gt; \u0026lt;family\u0026gt;Noto Serif CJK SC\u0026lt;/family\u0026gt; \u0026lt;family\u0026gt;Noto Serif CJK TC\u0026lt;/family\u0026gt; \u0026lt;family\u0026gt;Noto Serif CJK JP\u0026lt;/family\u0026gt; \u0026lt;family\u0026gt;Noto Serif CJK KR\u0026lt;/family\u0026gt; \u0026lt;family\u0026gt;Lohit Devanagari\u0026lt;/family\u0026gt; \u0026lt;/prefer\u0026gt; \u0026lt;/alias\u0026gt; \u0026lt;alias\u0026gt; \u0026lt;family\u0026gt;monospace\u0026lt;/family\u0026gt; \u0026lt;prefer\u0026gt; \u0026lt;family\u0026gt;Noto Sans Mono CJK SC\u0026lt;/family\u0026gt; \u0026lt;family\u0026gt;Noto Sans Mono CJK TC\u0026lt;/family\u0026gt; \u0026lt;family\u0026gt;Noto Sans Mono CJK HK\u0026lt;/family\u0026gt; \u0026lt;family\u0026gt;Noto Sans Mono CJK JP\u0026lt;/family\u0026gt; \u0026lt;family\u0026gt;Noto Sans Mono CJK KR\u0026lt;/family\u0026gt; \u0026lt;/prefer\u0026gt; \u0026lt;/alias\u0026gt; \u0026lt;/fontconfig\u0026gt; 效果：\n","date":"2022-05-21T10:30:00+08:00","image":"https://bestoko.cc/p/linux-fonts-size/ubuntu-logo_hu7abe99b24ad4c82a84734007a65ae91a_10499_120x120_fill_box_smart1_3.png","permalink":"https://bestoko.cc/p/linux-fonts-size/","title":"Ubuntu 20.04 英文环境部分中文字体异形解决方案"},{"content":"​\t对 Linux 用户来说, 一个美观方便的终端可以提高很多工作效率.我所推荐的终端方案是 zsh + oh-my-zsh + Powerlevel10k ,兼顾美观与高效. 我所在的公司开发环境是 Ubuntu 20.04 , 本文就以这此发行版为例进行配置.\nZsh 安装 zsh\n1 sudo apt install zsh 将 zsh 设置为默认 shell\n1 chsh -s /bin/zsh 你可以用echo $SHELL 指令来查看当前的默认 shell 是否修改成功.\noh-my-zsh 安装 oh-my-zsh\n1 sh -c \u0026#34;$(curl -fsSL https://gitee.com/shmhlsy/oh-my-zsh-install.sh/raw/master/install.sh)\u0026#34; 安装一些实用插件\n1 2 3 4 5 6 7 8 #自动补齐 git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh}/plugins/zsh-autosuggestions #语法高亮 git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh}/plugins/zsh-syntax-highlighting #自动跳转 sudo apt-get install autojump 配置插件\n1 2 3 4 5 6 7 8 9 10 vim ~/.zshrc #在 plugins 行添加插件名,如: plusgins=(git zsh-autosuggestions zsh-syntax-highlighting) #最后一行添加 . /usr/share/autojump/autojump.sh #使配置生效 source ~/.zshrc Powerlevel10k 安装 Powerlevel10k\n1 git clone --depth=1 https://github.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k 配置\n1 2 3 vim ~/.zshrc #修改 ZSH_THEME=\u0026#34;powerlevel10k/powerlevel10k\u0026#34; source ~/.zshrc 安装字体 (便于显示各种特殊符号和图表)\n[MesloLGS NF Regular.ttf](https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS NF Regular.ttf) [MesloLGS NF Bold.ttf](https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS NF Bold.ttf) [MesloLGS NF Italic.ttf](https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS NF Italic.ttf) [MesloLGS NF Bold Italic.ttf](https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS NF Bold Italic.ttf) 最后启动终端跟着向导配置,或者 p10k configure 就可以完成配置了.\n","date":"2022-03-08T20:56:36+08:00","image":"https://bestoko.cc/p/zsh/prompt-styles-high-contrast_hu84459e5b4ae7a52bf5b67b42f57bdcae_62099_120x120_fill_box_smart1_3.png","permalink":"https://bestoko.cc/p/zsh/","title":"Ubuntu 20.04 终端插件配置与美化"},{"content":"自用的电脑是Arch Linux和windows10双系统, 今天想着把win10抹掉装win11, 装完后从grub引导界面无法进入windows, 才想起来忘记考虑引导的事情了.\n下面给出一个简单的解决办法:\n1 sudo pacman -S prober 安装 os-prober , 这个工具可以帮助自动发现包含windows的分区\n(如果你的windows分区启用了bitlocker, 你可能还需要先使用dislocker)\n接着:\n1 sudo grub-mkconfig -o /boot/grub/grub.cfg 利用 grub-mkconfig 探测其他已经安装的系统并自动把他们添加到启动菜单.\n如果你得到以下输出：Warning: os-prober will not be executed to detect other bootable partitions，你需要编辑/etc/default/grub并取消下面这一行的注释，如果没有相应注释的话就在文件末尾添加上：\n1 GRUB_DISABLE_OS_PROBER=false ","date":"2022-03-05T19:19:15+08:00","image":"https://bestoko.cc/p/grubfix/fix-grub_hu2affd397a92bbc63783314cc40d8173f_294660_120x120_fill_q75_box_smart1.jpg","permalink":"https://bestoko.cc/p/grubfix/","title":"Arch Linux与Win11双系统修复grub引导"},{"content":"平台架构 https://developer.android.com/guide/platform?hl=zh-cn\n从下到上依次分为：\nLinux内核层 硬件抽象层 HAL 系统运行库层 Java API 框架 系统应用 每一层都包含大量的子模块或子系统。\nLinux内核层 (Linux Kernel) Android 平台的基础是 Linux 内核。例如，Android Runtime (ART) 依靠 Linux 内核来执行底层功能，例如线程和低层内存管理。\n使用 Linux 内核可让 Android 利用主要安全功能，并且允许设备制造商为著名的内核开发硬件驱动程序。\nAndroid平台以Linux内核为基础，避开了直接与硬件打交道，为驱动开发提供了高度扩展性和易用性，大大降低了 Android 系统移植工作的难度。\n硬件抽象层 (Hardware Abstract Layer,HAL) 硬件抽象层 (HAL) 提供标准界面，向更高级别的 Java API 框架显示设备硬件功能。HAL 包含多个库模块，其中每个模块都为特定类型的硬件组件实现一个界面，例如相机或蓝牙模块。当框架 API 要求访问设备硬件时，Android 系统将为该硬件组件加载库模块。\nLinux内核层与HAL层共同实现了对硬件的支持。其中HAL层运行在用户空间(User Space)，而Linux内核驱动程序运行在内核空间(Kernel Space)。为什么不把它们整合起来放到内核空间呢？技术角度是可以实现的，然而商业角度上会损害硬件厂商的利益。Linux内核源代码版权遵循GNU License(发布产品时必须公布源代码)，而Android源代码版权遵循Apache License(发布产品时无须公布源代码)。\n也就是说，Android放在内核空间的驱动程序对硬件的支持是不完整的，因此被踢出Linux内核主线代码树。\n系统运行库层 这一层中包含了支撑整个系统正常运行的基础库，由系统类库和Android运行时组成。由于这些库多数由C/C++实现，因此也被一些开发人员称为“C库层”，以区别应用程序框架层。\n原生 C/C++ 库 (Native C/C++ Libraries) 许多核心 Android 系统组件和服务(例如 ART 和 HAL)构建自原生代码，需要以 C 和 C++ 编写的原生库。Android 平台提供 Java 框架 API 以向应用显示其中部分原生库的功能。例如，您可以通过 Android 框架的 Java OpenGL API 访问 OpenGL ES，以支持在应用中绘制和操作 2D 和 3D 图形。\n如果开发的是需要 C 或 C++ 代码的应用，可以使用 Android NDK 直接从原生代码访问某些原生平台库。\n名称 简介 Webkit 一个开源的Web浏览器引擎 OpenMAX AL 一个不需要授权、跨平台的软件抽象层，以C语言实现的软件接口，用来处理多媒体。 Libc Linux下的ANSI C的函数库 Media Framework 基于PacketVideo的OpenCORE的多媒体库，支持多种常见音视频格式的录制和播放 OpenGL ES 免授权费的，跨平台的，功能完善的2D和3D图形应用程序接口API，主要针对多种嵌入式系统专门设计 Android运行时 (Android Runtime) 对于运行 Android 5.0(API 级别 21)或更高版本的设备，每个应用都在其自己的进程中运行，并且有其自己的 Android Runtime (ART) 实例。ART 编写为通过执行 DEX 文件在低内存设备上运行多个虚拟机，DEX 文件是一种专为 Android 设计的字节码格式，经过优化，使用的内存很少。编译工具链(例如 Jack)将 Java 源代码编译为 DEX 字节码，使其可在 Android 平台上运行。\nART 的部分主要功能包括：\n预先 (AOT) 和即时 (JIT) 编译\n优化的垃圾回收 (GC)\n在 Android 9(API 级别 28)及更高版本的系统中，支持将应用软件包中的 Dalvik Executable 格式 (DEX) 文件转换为更紧凑的机器代码。\n更好的调试支持，包括专用采样分析器、详细的诊断异常和崩溃报告，并且能够设置观察点以监控特定字段\n在 Android 版本 5.0(API 级别 21)之前，Dalvik 是 Android Runtime。如果您的应用在 ART 上运行效果很好，那么它应该也可在 Dalvik 上运行，但反过来不一定。\nAndroid 还包含一套核心运行时库，可提供 Java API 框架所使用的 Java 编程语言中的大部分功能，包括一些 Java 8 语言功能。\nJava API 框架 (Java API Framework) 您可通过以 Java 语言编写的 API 使用 Android OS 的整个功能集。这些 API 形成创建 Android 应用所需的构建块，它们可简化核心模块化系统组件和服务的重复使用，包括以下组件和服务：\n丰富、可扩展的视图系统，可用以构建应用的 UI，包括列表、网格、文本框、按钮甚至可嵌入的网络浏览器 资源管理器，用于访问非代码资源，例如本地化的字符串、图形和布局文件 通知管理器，可让所有应用在状态栏中显示自定义提醒 Activity 管理器，用于管理应用的生命周期，提供常见的导航返回栈 内容提供程序，可让应用访问其他应用(例如“联系人”应用)中的数据或者共享其自己的数据 开发者可以完全访问 Android 系统应用使用的框架 API。\n与\u0026quot;C库层\u0026quot;对应，这一层往往被称作“Java库层”。一方面为上层应用层提供API接口，另一方面也是不少系统级服务进程的实现，是与Android应用开发者关系最直接的一层。提供了开发Android应用程序所需的一系列类库，高度封装直接调用。应用框架层的主要实现代码在frameworks/base和frameworks/av目录下。\n系统应用 (System Apps) Android 随附一套用于电子邮件、短信、日历、互联网浏览和联系人等的核心应用。平台随附的应用与用户可以选择安装的应用一样，没有特殊状态。因此第三方应用可成为用户的默认网络浏览器、短信 Messenger 甚至默认键盘(有一些例外，例如系统的“设置”应用)。\n系统应用可用作用户的应用，以及提供开发者可从其自己的应用访问的主要功能。例如，如果您的应用要发短信，您无需自己构建该功能，可以改为调用已安装的短信应用向您指定的接收者发送消息。\n源码根目录中的packages目录对应着系统应用，其中：\napps 核心应用程序 experimental 第三方应用程序 inputmethods 输入法目录 providers 内容提供者目录 screensavers 屏幕保护 services 通信服务 wallpaper 墙纸 ","date":"2022-03-03T20:00:00+08:00","image":"https://bestoko.cc/p/android-framework/android-logo_hu0d2a9d549e5b2563e0cd181449ce1b0a_79982_120x120_fill_box_smart1_3.png","permalink":"https://bestoko.cc/p/android-framework/","title":"Android平台架构学习笔记"},{"content":"写在前面 本文不讨论科学上网的对错 本文不教学代理服务器部署 本文不推荐任何机场 Linux平台有很多成熟可靠的科学上网工具，本文仅列出我所推荐使用的，其余方案请自行搜索。\nClash for windows Clash 是一个使用 Go 语言编写，基于规则的跨平台代理软件核心程序。 Clash for Windows (cfw)是一个Windows/macOS/Linux下的clash图形化客户端。 支持的协议： Vmess, Shadowsocks, Snell , Sock5 , ShadowsocksR\n安装 你可以直接从cfw的github页下载解压使用，也可以通过flatpak来安装在你所需要的任何Linux系统上。\nFlatpak是一个类似snap的程序包管理程序，要使用Flatpak软件包，你的Linux发行版必须具有Flatpak支持。\n某些发行版（如Fedora Solus）默认情况下都具有Flatpak支持.\n以Arch Linux为例安装Flatpak。\n1 sudo pacman -S flatpak [注]如果只为了使用cfw的话，其实Arch Linux不必多次一举，AUR上已经有人打包好了。\n1 yay -S clash-for-windows-bin 安装cfw\n1 flatpak install flathub io.github.Fndroid.clash_for_windows 配置 打开 Clash for Windows ，在左侧的标签页选择Profiles， 在顶部输入 Clash 订阅链接 ，然后点击Download按钮。\nClash for Windows 会自动拉取配置文件进行更新，如果一切顺利，你应当可以看到绿色提示信息Success!，并且可以看到一个新增的配置文件。\n点击新增的配置文件来切换到该配置，然后点击Proxies 标签页来切换接入点，将顶部的出站模式选择为Rule。 此模式下你的网络访问请求将通过 Clash for Windows 进行分流处理。\n在Proxy策略组中选择所想要使用的接入点。Proxy 策略组是用于访问国际网络的默认策略，在不进行其他修改的情况下，所有国际网络的访问都通过 Proxy 策略组中选择的接入点进行。\n图中所示的其它策略组为本人出于自身实际需求自行配置的，请以自己的实际配置为准。\n此外你还需要在系统设置里，配置好cfw的代理。默认端口为7890。\n常用的科学上网设置到此结束。\n补充设置 有时执行wget或curl来下载国外的东西，需要临时在终端启用代理时，可以使用如下命令\n1 2 export http_proxy=http://127.0.0.1:7890 export https_proxy=http://127.0.0.1:7890 ","date":"2022-01-05T11:59:35+08:00","image":"https://bestoko.cc/p/linux-clash-for-windows/cfw_hu9db59739f206d08ecaf1f4b03c5d9443_57712_120x120_fill_box_smart1_3.png","permalink":"https://bestoko.cc/p/linux-clash-for-windows/","title":"我的Linux科学上网方案"},{"content":"在extensions.gnome.org上找到个农历扩展Lunar Calendar 农历，直接安装会因为缺少依赖报错，搜到的rpm包也无法正常安装，查了下需要手动编译安装lunar-date。\nFedora35 编译安装lunar-date github页给的安装指南如下\n1 2 3 meson build --prefix /usr -Ddocs=true -Dintrospection=true -Dvapi=true -Dtests=true ninja -C build/ sudo ninja -C build install meson是用Python语言开发的构建工具，编译需要Ninja（用C++实现）命令。\n所以首先\n1 sudo dnf install meson ninja-build 接着运行指南上第一条指令，如果有依赖缺失会报错，但是提示的依赖名称不能直接用于dnf install,可以在command-not-found.com 查询所需安装指令。以我为例：\n1 sudo dnf install vala gtk-doc 接着重新安装插件就可以正常启用了。\n额外可选设置 默认情况下当系统语言为中文时扩展可以正常工作，但是像我一样习惯系统语言用英文的话，农历会以拼音形式标注出来（真的很难看），解决办法如下：\n1 cp /usr/share/locale/zh_CN/LC_MESSAGES/lunar-date.mo /usr/share/locale/en_US/LC_MESSAGES/lunar-date.mo ","date":"2021-12-30T09:18:46+08:00","image":"https://bestoko.cc/p/gnome-lunar-calendar/calendar_huc965ea0dc5f40a0bcc0496d3e43e9f6a_402882_120x120_fill_box_smart1_3.png","permalink":"https://bestoko.cc/p/gnome-lunar-calendar/","title":"Gnome农历插件安装踩坑记录"},{"content":"双系统用了一段时间后，开机黑洞洞的grub界面自然看着不爽 （虽然只有几秒）,于是想着去美化一下，其中遇到了点小坑，记录一下。使用的机器装了Windows11和Fedora35。\n下载主题 首先下载好你想要的主题文件，我选择的是这个MacOS风格的MacOS Monterey inspired grub theme\n修改/etc/default/grub文件 首先，注释掉GRUB_TERMINAL_OUTPUT=”console”,接着设置好你的GRUB主题路径。\n1 2 #GRUB_TERMINAL_OUTPUT=”console” GRUB_THEME=\u0026#34;/boot/grub2/montery-grub-theme/theme.txt\u0026#34; 此外这个文件里还有几个常用的设置 GRUB_TIMEOUT=5 可以设置超时时间，设置-1可以取消倒计时 GRUB_DEFAULT=saved saved：光标会默认选择上一个成功进入的启动项，也可以填入数字，以指定启动列表中第x项为启动项，x从0开始计数\n更新Grub2配置 如果跟我一样使用GPT分区，以UEFI启动方式的话，启动时读取的位置是/boot/efi/EFI/fedora/grub.cfg ，更新命令如下：\n1 sudo grub2-mkconfig -o /boot/efi/EFI/fedora/grub.cfg 而如果是启动方式是Legacy的话，启动时读取的文件是/boot/grub2/grub.cfg，更新命令如下：\n1 sudo grub2-mkconfig -o /boot/grub2/grub.cfg 接着reboot即可看到效果。\n","date":"2021-12-29T18:56:18+08:00","image":"https://bestoko.cc/p/fedora-grub2-theme/grub2_hu594604db0bf5dc83cbe0fc3e9035594c_43340_120x120_fill_q75_box_smart1.jpg","permalink":"https://bestoko.cc/p/fedora-grub2-theme/","title":"Grub2主题美化踩坑记录"},{"content":"在 Arch Linux 上使用 Virtual Box 制作虚拟机，打开时却出了问题。\n报错信息 Kernel driver not installed (rc=-1908)\nVirtualBox Linux 内核驱动程序未加载或未正确设置。\n解决办法 执行如下命令，重新安装vboxdrv模块\n1 sudo modprobe vboxdrv 如果不起作用，检查下是否在BIOS/UEFI设置中禁用安全启动（Secure Boot），因为安全启动会阻止加载未签名的模块。\n","date":"2021-12-28T11:21:20+08:00","image":"https://bestoko.cc/p/linux-virtualbox-error/virtualbox-oracle_hu92c877dfd4fe632d733454f9d7c15e29_39250_120x120_fill_q75_box_smart1.jpg","permalink":"https://bestoko.cc/p/linux-virtualbox-error/","title":"Linux上VirtualBox启动时sbin/vboxconfig错误的解决办法"},{"content":"给常用的电脑加了块固态装了Arch linux，结果在切换双系统时出现两个系统时间不一致的现象，是我之前在Surface上单系统所没遇到的。\n为什么时间不一致 这是因为BIOS硬件时间本身并没有时区概念，但Windows和Linux对Bios硬件时间与时区关系的理解不一样。Linux将BIOS硬件时间视为协调世界时（UTC），即不存在本地时区；而Windows则将BIOS硬件时间视为当地时间，带上了设置后的时区。Windows这样做，一是早期为了兼容MS-DOS/Windows 3.x，二是为了照顾大众，防止用户问为什么BIOS显示的时间和实际不一致。\n中国大陆、中国香港、中国澳门、中国台湾、蒙古国、新加坡、马来西亚、菲律宾、西澳大利亚州的时间与UTC的时差均为+8，也就是UTC+8。\n推荐的解决办法 Windows 其实也能处理 UTC，需要修改注册表。建议让 Windows 使用 UTC，而非让 Linux 使用地方时。Windows 使用 UTC 后，请记得禁用 Windows 的时间同步功能，以防 Windows 错误设置硬件时间。\nLinux 可以使用NTP服务来在线同步硬件时钟。\n使用 regedit,新建如下 DWORD 值，并将其值设为十六进制的 1。\n1 HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\TimeZoneInformation\\RealTimeIsUniversal 也可以用管理员权限启动命令行来完成：\n1 reg add \u0026#34;HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\TimeZoneInformation\u0026#34; /v RealTimeIsUniversal /d 1 /t REG_DWORD /f 如果以上操作不起作用，并且你使用的是 Windows 64位系统，将 DWORD 修改为 QWORD。\n参考：https://wiki.archlinux.org/index.php/System_time#UTC_in_Windows\n","date":"2021-12-27T21:14:01+08:00","image":"https://bestoko.cc/p/linux-windows-time-conflict/linux-windows-time-conflict_hu55b4f0060a402cf399162415184cf7cf_158865_120x120_fill_box_smart1_3.png","permalink":"https://bestoko.cc/p/linux-windows-time-conflict/","title":"Linux与Windows双系统时间不一致的解决方法"},{"content":" 虽然我一直不觉得自己是软粉，但是不知不觉中M$家的产品越用越顺手了。\nMicroSoft To-Do作为代办清单app来说，简洁实用，同步方便，而最近在适应Arch Linux的我，实在用不惯gnome桌面自带的ToDo，必须想办法换回去。\nSnaps安装与配置 snap是Canonical公司发布的全新的软件包管理方式，它类似一个容器拥有一个应用程序所有的文件和库，各个应用程序之间完全独立。所以使用snap包的好处就是它解决了应用程序之间的依赖问题，使应用程序之间更容易管理。但是由此带来的问题就是它占用更多的磁盘空间。\n也就是说，对于生态系统碎片化严重的Linux来说，Snaps像是它们的中间地带，不管运行哪种Linux分支，都能轻易通过Snaps获取想要的应用程序包。\n安装Snap软件包 首先，赞美AUR，snapd及其依赖包snap-confine和squashfs-tools都在仓库里了。\n1 sudo pacman -S snapd 启动守护进程 1 sudo systemctl enable --now snapd.socket 启用classic snap support 1 sudo ln -s /var/lib/snapd/snap /snap 接着log out或者reboot一下来确保snap的路径正确更新。\nStrict\nUsed by the majority of snaps. Strictly confined snaps run in complete isolation, up to a minimal access level that’s deemed always safe. Consequently, strictly confined snaps can not access your files, network, processes or any other system resource without requesting specific access via an interface (see below).\nClassic\nAllows access to your system’s resources in much the same way traditional packages do. To safeguard against abuse, publishing a classic snap requires manual approval, and installation requires the \u0026ndash;classic command line argument.\n以上是Snap官方给出的定义，classic是与strict相对的。在默认情况下，Snap使用的是strict模式，对安全权限做了极高的要求与限制，而classic就和传统的安装包一样对安全权限没有限制，其实这里的classic就约等于确认已知不安全的风险的含义。\n安装MicroSoft To-Do(unofficial) 安装并配置好snap后就很简单了：\n1 sudo snap install micro-soft-todo-unofficial 日后更新：\n1 sudo snap refresh micro-soft-todo-unofficial 如果要卸载：\n1 sudo snap remove micro-soft-todo-unofficial ","date":"2021-12-22T01:15:01+08:00","image":"https://bestoko.cc/p/snaps-mstodo/snap_hu403091d3742fd6d7492182b7a71661e5_43013_120x120_fill_box_smart1_3.png","permalink":"https://bestoko.cc/p/snaps-mstodo/","title":"Arch Linux上借助Snaps安装MicroSoft To-Do(unofficial)"},{"content":" 类比于Chrome 浏览器和其开源的“上游”项目 Chromium。VS Code 确实是基于开源代码库构建的。而微软官方发布的版本带有一些与微软相关的功能，包括一项商标、一个插件库、一个 C# 调试器以及遥测。但如果你克隆仓库然后自行编译，这些东西都不会被加入，所以你会得到一个名为 Code - OSS 的“干净”版本（OSS，Open-source software ）。\n我之前使用\n1 pacman -S code 所安装的正是Code-OSS ，默认不使用微软官方扩展市场。\n方法一 我们可以通过修改/usr/lib/code/product.json解决这个问题，添加如下内容：\n1 2 3 4 5 \u0026#34;extensionsGallery\u0026#34;: { \u0026#34;serviceUrl\u0026#34;: \u0026#34;https://marketplace.visualstudio.com/_apis/public/gallery\u0026#34;, \u0026#34;cacheUrl\u0026#34;: \u0026#34;https://vscode.blob.core.windows.net/gallery/index\u0026#34;, \u0026#34;itemUrl\u0026#34;: \u0026#34;https://marketplace.visualstudio.com/items\u0026#34; } 重新启动Code-OSS就可以了。\n方法二 方法一正常使用一段时间后，在某次重启后出现打不开Code-OSS的情况，所幸从AUR上找到了另一个包解决了问题，记录在此。\n1 yay -S code-marketplace ","date":"2021-12-20T09:00:01+08:00","image":"https://bestoko.cc/p/code-oss-extensions/code-oss_hu8b3034d3b76254d70eabeb74d0dd9f1e_41316_120x120_fill_box_smart1_3.png","permalink":"https://bestoko.cc/p/code-oss-extensions/","title":"Arch Linux上修改Code-OSS扩展源"},{"content":"写在前面 之前我已经在Surface Pro 上安装了Arch Linux，可是由简入奢易，由奢入艰难，习惯了的二合一设备突然不能正常触屏还是有些不爽（之前买的surface pen也成了摆设），于是我在github上找到了第三方内核。由于是第三方内核，各设备各硬件的适配情况并不完善，具体可以查看这里。\n安装驱动 导入密钥 首先我们需要导入用于签名软件包的密钥：\n1 2 $ curl -s https://raw.githubusercontent.com/linux-surface/linux-surface/master/pkg/keys/surface.asc \\ | sudo pacman-key --add - 检查完整性并本地签名 1 2 $ sudo pacman-key --finger 56C464BAAC421453 $ sudo pacman-key --lsign-key 56C464BAAC421453 添加存储库 我们需要在/etc/pacman.conf添加如下内容\n1 2 [linux-surface] Server = https://pkg.surfacelinux.com/arch/ 更新存储库数据，安装内核，启用服务 我们需要更新存储库数据，以安装linux-surface内核及其依赖项，接着启用iptsd服务以使用触摸屏。\n1 2 3 $ sudo pacman -Syu $ sudo pacman -S linux-surface linux-surface-headers iptsd $ sudo systemctl enable iptsd 重启以后就完工了，屏幕触摸也支持了。\n","date":"2021-12-16T01:48:01+08:00","image":"https://bestoko.cc/p/surface-linux/surface_hu4dfd7a842b0b08077966cbe869e7c3b7_55232_120x120_fill_q75_box_smart1.jpg","permalink":"https://bestoko.cc/p/surface-linux/","title":"Surface设备在Arch Linux下驱动问题的解决方案"},{"content":"写在前面 在安装了基本的ArchLinux后，我们还需要一些配置、安装一些组件，来扩展系统功能，使其更符合我们日常使用习惯。\n配置网络 我们使用\n1 nmtui 选择Edit a connection，\n选择Add菜单，选择WI-FI，\nDevice 里输入 无线网卡的名字，SSID里输入WI-FI的名字，Security选择WPA \u0026amp;WPA2 Personal，OK-BACK-Quit退出。\n注：使用以下命令查看无线网卡名称\n1 ip link show 重命名主机 1 vim /etc/hostname 保存想要的名字后退出。\n接下来把主机名、域名以及ip地址进行映射\n1 vim /etc/hosts 输入：(以下archlinux为上文所保存的主机名)\n1 2 3 127.0.0.1\tlocalhost ::1\tlocalhost 127.0.0.1 archlinux.localdomain\tarchlinux 设置系统时间 1 2 timedatectl set-timezone Asia/shanghai timedatectl set-ntp true 第二行设置为让本机时间与ntp同步。\n配置环境变量 1 vim /etc/skel/.bashrc 添加以下内容\n1 2 3 4 5 6 7 8 export EDITOR=vim alias grep=\u0026#39;grep ==color=auto\u0026#39; alias egrep=\u0026#39;egrep ==color=auto\u0026#39; alias fgrep=\u0026#39;fgrep ==color=auto\u0026#39; [ ！ -e ~/.dircolors ] \u0026amp;\u0026amp; eval $(dircolors -p \u0026gt; ~/.dircolors) [ ！ -e /bin/dircolors ] \u0026amp;\u0026amp; eval $(dircolors -b \u0026gt; ~/.dircolors) 将bash shell 默认的文本编辑器设置为vim\n为grep，egrep，fgrep搜索出的内容添加颜色\n为看到的文件以及文件夹添加颜色\n1 cp -a . ~ 新建标准用户 1 2 3 useradd --create-home username passwd username usermod -aG wheel,users,storage,power,lp,adm,optical username 其中username替换为你所使用的名字，在创建时同时在/home目录下会创建一个与用户名同名的文件夹。家目录有一个别名是~，你可以在任何地方使用~来代替家目录路径。\n配置sudo 1 visudo 将# %wheel ALL=(ALL) ALL 前的#号去除（去注释），保存退出。\n中英字体和图形界面的安装 安装Xorg Xorg是Linux下的一个著名的开源图形服务，我们的桌面环境需要Xorg的支持。\n1 pacman -S xorg 显卡驱动的安装 参照如上表格安装相应的包，以Surface Pro 为例，需要安装intel的集成显卡驱动\n1 pacman -S xf86-video-intel 安装字体 1 vim /etc/locales.gen 将en_US.UTF-8 UTF8 zh_CN.UTF-8 UTF8前的#删除（去注释），保存退出。\n1 vim /etc/locale.conf 输入\n1 LANG=en_US.UTF-8 如果想生成中文，就改成LANG=zh_TW.UTF-8\n接着生成字体\n1 locale-gen 接下来安装英文字体\n1 pacman -S ttf-dejavu ttf-droid ttf-hack ttf-font-awesome otf-font-awesome ttf-lato ttf-liberation ttf-linux-libertine ttf-opensans ttf-roboto ttf-ubuntu-font-family 再然后是安装中文字体\n1 pacman -S ttf-hanom noto-fonts noto-fonts noto-fonts-extra not-fonts-emoji noto-fonts-cjk adobe-source-code-pro-fonts adobe-source-sans-fonts adobe-source-serif-fonts adobe-source-han-sans-cn-fonts adobe-source-han-sans-hk-fonts adobe-source-han-sans-tw-fonts adobe-source-han-serif-cn-fonts wqy-zenhei wqy-microhei 打开freetype2字体引擎\n1 vim /etc/profile.d/freetype2.sh 将最后一行去注释后保存退出。\n安装桌面环境 Linux下有很多桌面环境如Xfce、KDE(Plasma)、Gnome、Unity、Deepin等等，它们的外观、操作、设计理念等各方面都有所不同，这里我们选择Gnome为例，进行安装。\n1 pacman -S gnome gnome-extra gdm 安装好了桌面环境包以后，我们需要安装一个图形化的桌面管理器来帮助我们登录并且选择我们使用的桌面环境，这里我使用上面的gdm\n1 systemctl enable gdm.service 安装声音以及打印机系统 1 pacman -S alsa-utils pulseaudio pulseaudio-bluetooth cups 清楚安装缓存以及无用源 1 pacman -Scc 接着重启即可进入Gnome桌面\n小结 至此，ArchLinux基本安装与必要设置和图形界面都已经安装完毕。\n","date":"2021-12-15T09:00:01+08:00","image":"https://bestoko.cc/p/archinstallextra/ArchLinux_hu13d81b556f6c7780a085a162084854bc_14536_120x120_fill_q75_box_smart1.jpg","permalink":"https://bestoko.cc/p/archinstallextra/","title":"Arch Linux安装备忘录（二）"},{"content":"写在前面 安装Arch最好最全面的教程就是官方的 Installation guide。但是Wiki上的介绍更偏向文档，而不是新手习惯的那种按步骤编排的教程，加上中文Wiki的翻译往往落后于英文版，缺乏预备Linux知识的新手经常无从下手。\n笔者也是初学者，本篇文章仅作为自己在Surface Pro 2017从0开始安装配置Arch的记录。\n安装准备 磁盘准备 我们需要准备一块有空闲区域（没有被分区）的磁盘留给系统的安装。笔者只准备安装Arch单系统，因此在PE里用磁盘管理工具把Surface的磁盘0各个分区全部删除。你也可以在Windows下找到磁盘管理，自行划分一个区域留给安装使用。\n安装介质 https://www.archlinux.org/download/ 建议从下面的中国镜像下载iso文件\nhttps://rufus.ie/ 我们用Rufus来制作引导盘，此步需要用到一个空闲U盘。需要注意的是写入方式选择DD，分区类型选择GPT而非默认的MBR。\n设置启动顺序 接下来需要进入个人电脑的BIOS里把制作的U盘启动设置为第一位，笔者的Surface额外需要先关闭security boot，不同电脑进入BIOS的按键略有不同，Surface是开机键和音量+键，其他型号电脑请查阅搜索引擎。\n安装过程 正确设置好启动顺序后，启动时会看到ArchLinux的界面，按Enter键选择 Boot Arch Linux ，等待加载完成后会进入一个有命令提示符的界面。我们接下来将在这个界面执行一系列命令来讲Arch安装到之前准备的磁盘上。\n*网络连接 Arch的安装需要联网，如果你使用的是有线连接，可以跳过此部分，笔者这里使用无线连接继续安装。\n输入\n1 iwctl 进入iwd模式，输入\n1 device list 查看你的网卡名字，这里假设是wlan0，输入\n1 station wlan0 scan 检查扫描网络，输入\n1 station wlan0 get-networks 查看网络名字，假设名字叫XXX，输入\n1 station wlan0 connect XXX 接着输入密码（如果有密码的话），输入\n1 exit 退出iwd模式\n我们可以用ping命令来检验下是否连接成功\n1 ping -c 4 baidu.com 接下来我们需要让安装介质里的数据库保持与官方一致的最新版本，因此需要同步一下，在此之前，我们可以配置下最新的镜像来保证下载速度。\n1 reflector --country China --age 24 --sort rate --portocol https --save /etc/pacman.d/mirrorlist country 限定国家 age 24 限定下更新时间为24小时内的源 portocol https 选择https协议更安全 执行完毕后，可以用vim查看\n1 vim /etc/pacman.d/mirrorlist 磁盘分区 检查磁盘\n1 lsblk 用gdisk命令进行分区\n1 gdisk /dev/nvme0n1 其中nvme01 为你之前准备的磁盘。\n一路默认回车到Last sector 部分，因为我们准备用作启动分区，准备分配512M，所以输入+512M回车，接着输入分区编号ef00。这样第一个分区完成，接着第二个分区笔者分配了+235G，并使用默认的分区编号8300（Linux filesystem），最后剩下2G左右空间一路默认，分区编号输入8200（Linux swap）。确认无误后，w保存quit退出。\n接着格式化我们的三个分区，将nvme01p1格式化为vfat\n1 mkfs.vfat /dev/nvme01p1 将nvme01p2格式化为ext4或者xfs（推荐）\n1 mkfs.xfs /dev/nvme01p2 最后\n1 mkswap /dev/nvme01p3 挂载分区 1 mount /dev/nvme01p2 /mnt 1 mkdir -p /mnt/boot/efi 1 mount /dev/nvme01p1 /mnt/boot/efi 1 swapon /dev/nvme01p3 安装基本包 1 pacstrap /mnt base base-devel linux linux-firmware linux-headers vim bash-completion 配置Fstab 1 genfstab -U /mnt \u0026gt;\u0026gt; /mnt/etc/fstab 1 cat /mnt/etc/fstab 确认下是否挂载无误\nchroot Chroot意为Change root，相当于把操纵权交给我们新安装（或已经存在）的Linux系统，执行了这步以后，我们的操作都相当于在磁盘上新装的系统中进行。\n1 arch-chroot /mnt 安装必须软件包 现在我们已经Chroot到了新的系统中，只有一些最基本的包（组件），这时候我们就需要自己安装新的包。ArchLinux有非常强大的包管理工具pacman，大部分情况下，一行命令就可以搞定包与依赖的问题。\n安装包的命令格式为pacman -S 包名，pacman会自动检查这个包所需要的其他包（即为依赖）并一起装上。下面我们就通过pacman来安装一些包，这些包在之后会用上，在这里先提前装好。\n执行如下命令（注意大小写，大小写错误会导致包无法找到）：\n1 pacman -S grub efibootmgr efivar networkmanager intel-ucode AMD用户请将intel-ucode替换成amd-ucode\n安装Bootloader 部署grub\n1 grub-install /dev/nvme01 修改配置\n1 vim /etc/default/grub 将GRUB_TIMEOUT=5改成GRUB_TIMEOUT=2\n将GRUB_CMDLINE_LINUX_DEFAULT=\u0026quot;loglevel=3 quiet\u0026quot; 的quiet字段删除，这样登录的时候会有日志，如果出现错误可以查看日志文件。\n接着将GRUB_GFXMODE=auto修改为你的分辨率，以我的surface为例，改为GRUB_GFXMODE=2736x1824\n接着生成grub的配置文件\n1 grub-mkconfig -o /boot/grub/grub.cfg 设置NetworkManager开机自动启动 1 systemctl enable NetworkManager 为root用户设置密码 1 passwd 卸载分区 拔除介质 1 2 umount /mnt/boot/efi umount /mnt 拔除介质重新启动\n1 reboot 小结 至此，我们成功安装了ArchLinux，然而此时系统处于非常精简的状态，距离日常使用还需要一些配置，安装一些需要的组件，下一部分我们将安装图形界面、配置显卡驱动、安装桌面环境\u0026hellip;.以及一些实用软件包。\n","date":"2021-12-14T09:00:01+08:00","image":"https://bestoko.cc/p/archinstall/ArchLinux_hu13d81b556f6c7780a085a162084854bc_14536_120x120_fill_q75_box_smart1.jpg","permalink":"https://bestoko.cc/p/archinstall/","title":"Arch Linux安装备忘录（一）"},{"content":"准备工作 解锁Bootloader且打开USB调试的一加8\n氢OS Android11 Rom包\nPayload Dumber\nplatform-tools\n打包下载： pan.baidu.com/s/1afSr1snXan4LoBLX9l0Urg 【pcge】\n刷入Magisk 制作magisk_patched.img 将官方包内的payload.bin 解压并放入Payload Dumber 的payload_input目录\n打开payload_dumper.exe（看到boot解压出来就可以关闭了）\n打开payload_output目录，将解压出的boot.img复制到手机根目录\n下载并安装Magisk最新版本 (https://github.com/topjohnwu/Magisk/releases)\n选择安装Magisk-选择并修补一个文件，选中放在根目录的boot.img ，等待修补完成\n将手机download目录下的修补完成的magisk_patched.img复制到电脑\n工具刷入mgisk_patched.img 将mgisk_patched.img放入 platform-tools 目录下\n运行\n1 打开CMD命令行.bat adb reboot bootloader fastboot flash boot_a magisk_patched.img fastboot flash boot_b magisk_patched.img fastboot reboot 刷入EdXposed 刷入Riru - Core模块 刷入Riru - EdXposed(YAHFA) 或Riru - EdXposed(SandHook)模块 安装最新的Edxposed Manager 总结与注意事项 制作mgisk_patched.img时要用最新的 v8.0.x版本，不能使用以往的v21.0版本\n刷写mgisk_patched.img时 a/b分区都要\n如果因刷入不兼容的模块导致无法开机，可以尝试\n卸载全部magisk模块\nadb shell magisk --remove-modules adb reboot ","date":"2020-10-28T09:00:01+08:00","image":"https://bestoko.cc/p/oneplus8/onepluslogo_hu7b2083ec43cbfc8c8606b4db91f24e67_30881_120x120_fill_q75_box_smart1.jpg","permalink":"https://bestoko.cc/p/oneplus8/","title":"一加8的Android 11 折腾指南"},{"content":"​\t最近刚开始刷Leetcode，第一道Hard题就难倒了我。题解里有位大神的算法很巧妙，我很容易就理解了，在此做个记录。\n题目链接：https://leetcode-cn.com/problems/median-of-two-sorted-arrays/\n题解链接：https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/4-xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-shu/\n题目 给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。\n请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。\n你可以假设 nums1 和 nums2 不会同时为空。\n示例 1:\nnums1 = [1, 3] nums2 = [2]\n则中位数是 2.0 示例 2:\nnums1 = [1, 2] nums2 = [3, 4]\n则中位数是 (2 + 3)/2 = 2.5\n分析 首先要理解中位数 中位数（Median）又称中值，统计学中的专有名词，是按顺序排列的一组数据中居于中间位置的数，代表一个样本、种群或概率分布中的一个数值，其可将数值集合划分为相等的上下两部分。对于有限的数集，可以通过把所有观察值高低排序后找出正中间的一个作为中位数。如果观察值有偶数个，通常取最中间的两个数值的平均数作为中位数。\n[2 3 5] 中位数是3\n[1 4 7 9] 中位数是(4+7)/2=5.5\n割(Cut)的概念 通过切一刀，可以把有序数组分成左右两个部分，切的那一刀就被称为割(Cut)。\n割(Cut)的左右会有两个元素，分别是左边最大值和右边最小值。\n定义LMax= Max(LeftPart) RMin = Min(RightPart) //由小到大的有序数组\n割可以割在2个数中间，也可以割在1个数上，如果割在一个数上，那么这个数既属于左边，也属于右边\n奇数组: [2 3 5] 对应的中位数为3，假定割(Cut)在3上，我们可以把3分为2个： [2（3/3） 5]\n因此LMax=3, RMin=3\n偶数组: [1 4 7 9] 对应的中位数为 (4 + 7) /2 = 5.5,假定割(Cut)在4和7之间： [1 （4/7）9]\n因此LMax=4, RMin=7\n割和第k个元素 一个数组 对于有序数组A，如果在k的位置割一下，容易得出LMax = RMin = A[k]\n两个数组 将两个数组合成一个有序数组时，第k位的元素\n我们设: Ci为第 i个数组的割\nLMaxi为第i个数组割后的左元素i\nRMini为第i个数组割后的右元素\nLeftpart Ci Rightpart a1,a2,\u0026hellip;,ai / ai+1,ai+2,\u0026hellip;,am b1,b2,\u0026hellip;,bj / bj+1,bj+2,\u0026hellip;,bn 首先，因为数组是有序的，所以LMax1 \u0026lt;= RMin1，LMax2 \u0026lt;= RMin2 //割在某个数上时左右相等\n其次，如果让LMax1 \u0026lt;= RMin2，LMax2 \u0026lt;= RMin1 呢？\n这表示左半边全部小于右半边。如果让左边的元素个数相加刚好为k，那第k个元素就是max(LMax1, Lmax2)，也就是合并后有序数组左边k个元素的最大值。\n那么如果LMax1 \u0026gt; RMin2，说明数组1的左边元素太多，我们把C1减小，C2 = k - C1相应地增大。LMax2 \u0026gt; RMin1同理，把C2减小，C1 = k - C2也就相应地增大。\n举例（设k = 3） [2 3 5] [1 4 7 9]\n设C1 = 1，则 C2 = k - C1 = 2 割后：\n[2 3 / 5] [1 / 4 7 9]\n此时，LMax1 = 3, RMin1 = 5, LMax2 = 1, RMin2 = 4,\n满足 LMax1 \u0026lt; RMin2 且 LMax2 \u0026lt; RMin1 ，\n所以第3个元素为max(LMax1, LMax2) = 3\n两个数组合并后的长度问题 （本篇题解巧妙所在） 两个数组的最大问题是，它们合并后，m+n总数可能为奇, 也可能为偶，所以我们得想法让m+n总是为偶数\n通过虚拟加入‘#’，我们让m转换成2m+1 ，n转换成2n+1, 两数之和就变成了2m+2n+2，恒为偶数。\n注意是虚拟加，其实根本没这一步，通过下面的转换，我们可以保证虚拟加后每个元素跟原来的元素一一对应\nbefore len after len [1 4 7 9] 4 [# 1 # 4 # 7 # 9] 9 [2 3 5] 3 [# 2 # 3 # 5 ] 7 这么虚拟加后，每个位置可以通过/2得到原来元素的位置：\n比如 2，原来在0位，现在是1位，1/2=0\n比如 3，原来在1位，现在是3位，3/2=1\n比如 5，原来在2位，现在是5位，5/2=2\n比如 9，原来在3位，现在是7位，7/2=3\n而对于割(Cut)，如果割在‘#’上等于割在2个元素之间，割在数字上等于把数字划到2个部分，总是有以下成立：\nLMaxi = (Ci-1)/2 位置上的元素 RMini = Ci/2 位置上的元素\n例如：\n割在3上，C = 3，LMax=a[(3-1)/2]=A[1]，RMin=a[3/2] =A[1]，刚好都是3的位置！\n割在4/7之间‘#’，C = 4，LMax=A[(4-1)/2]=A[1]=4 ，RMin=A[4/2]=A[2]=7\n剩下的事情就好办了，把2个数组看做一个虚拟的数组A，A有2m+2n+2个元素，割在m+n+1处，所以我们只需找到m+n+1位置的元素和m+n+2位置的元素就行了。\n左边：A[m+n+1] = Max(LMax1,LMax2)\n右边：A[m+n+2] = Min(RMin1,RMin2)\n==\u0026gt;Mid = (A[m+n+1]+A[m+n+2])/2 = (Max(LMax1,LMax2) + Min(RMin1,RMin2) )/2\n最快的割(Cut)是使用二分法，有2个数组，我们对哪个做二分呢？ 根据之前的分析，我们知道了，只要C1或C2确定，另外一个也就确定了。这里，为了效率，我们肯定是选长度较短的做二分，假设为C1。\nLMax1\u0026gt;RMin2，把C1减小，C2增大。—\u0026gt; C1向左二分\nLMax2\u0026gt;RMin1，把C1增大，C2减小。—\u0026gt; C1向右二分\n如果C1或C2已经到头了怎么办？ 这种情况出现在：如果有个数组完全小于或大于中值。假定n\u0026lt;m, 可能有4种情况：\nC1 = 0 —— 数组1整体都在右边了，所以都比中值大，中值在数组2中，简单的说就是数组1割后的左边是空了，所以我们可以假定LMax1 = INT_MIN\nC1 =2n —— 数组1整体都在左边了，所以都比中值小，中值在数组2中 ，简单的说就是数组1割后的右边是空了，所以我们可以假定RMin1= INT_MAX，来保证LMax2 \u0026lt; RMin1恒成立\nC2 = 0 —— 数组2整体在右边了，所以都比中值大，中值在数组1中 ，简单的说就是数组2割后的左边是空了，所以我们可以假定LMax2 = INT_MIN C2 = 2m —— 数组2整体在左边了，所以都比中值小，中值在数组1中, 简单的说就是数组2割后的右边是空了，为了让LMax1 \u0026lt; RMin2 恒成立，我们可以假定RMin2 = INT_MAX\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; #define max(a,b) (((a) \u0026gt; (b)) ? (a) : (b)) #define min(a,b) (((a) \u0026lt; (b)) ? (a) : (b)) class Solution { public: double findMedianSortedArrays(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2) { int n = nums1.size(); int m = nums2.size(); if (n \u0026gt; m) //保证数组1一定最短 { return findMedianSortedArrays(nums2, nums1); } // Ci 为第i个数组的割,比如C1为2时表示第1个数组只有2个元素。LMaxi为第i个数组割后的左元素。RMini为第i个数组割后的右元素。 int LMax1, LMax2, RMin1, RMin2, c1, c2, lo = 0, hi = 2 * n; //我们目前是虚拟加了\u0026#39;#\u0026#39;所以数组1是2*n长度 while (lo \u0026lt;= hi) //二分 { c1 = (lo + hi) / 2; //c1是二分的结果 c2 = m + n - c1; LMax1 = (c1 == 0) ? INT_MIN : nums1[(c1 - 1) / 2]; RMin1 = (c1 == 2 * n) ? INT_MAX : nums1[c1 / 2]; LMax2 = (c2 == 0) ? INT_MIN : nums2[(c2 - 1) / 2]; RMin2 = (c2 == 2 * m) ? INT_MAX : nums2[c2 / 2]; if (LMax1 \u0026gt; RMin2) hi = c1 - 1; else if (LMax2 \u0026gt; RMin1) lo = c1 + 1; else break; } return (max(LMax1, LMax2) + min(RMin1, RMin2)) / 2.0; } }; int main(int argc, char *argv[]) { vector\u0026lt;int\u0026gt; nums1 = { 2,3, 5 }; vector\u0026lt;int\u0026gt; nums2 = { 1,4,7, 9 }; Solution solution; double ret = solution.findMedianSortedArrays(nums1, nums2); return 0; } ","date":"2020-04-10T09:00:01+08:00","image":"https://bestoko.cc/p/leetcode004/leetcode_huc40bc8c685b4e68ad6cc20881a359f28_10178_120x120_fill_q75_box_smart1.jpg","permalink":"https://bestoko.cc/p/leetcode004/","title":"寻找两个有序数组的中位数"},{"content":"前情提要 为什么要水这么一篇文章\n在把switch借给朋友玩的这段时间，我把目光投向了吃灰已久的3ds\u0026hellip;.\n我想要在实机上游玩gba游戏，但是3ds上的模拟器又有各种各样的兼容性问题，达不到eshop里VC金银流畅的游玩体验；宣称能游玩GBA的DSTWO PLUS烧录卡早已停产，某宝/闲鱼的价格居高不下\u0026hellip;经过一番摸索，我找到了可能是现今最好的解决方案。\n准备工作 一台BOOT9STARP(B9S)破解的3ds\n参考3ds破解手册或者一只火狐大佬整理的教程(推荐)\n嫌麻烦的同学可以交给热心摊主处理\nUltimate GBA VC Injector for 3DS\n汉化版下载链接\n你想要在3ds上运行的GBA游戏ROM文件\n这里以漆黑的魅影为例（很棒的GBA宝可梦改版，我一直想在实机上玩）\nGBA 转CIA 打开软件并导入下载好的.gba文件，ROM大小和存档类型会自动确认(汉化版ROM往往是数据库未找到该游戏，请确保选择的正确无误以免影响存档) 填写要转换的VC图标和名称(因为3ds字库的原因建议不要使用中文XD)，设置3D横幅(就是选中这个游戏时3ds上屏的画面)\n设置VC参数并导出CIA文件(注意当转换多个.cia文件时，确保每个文件的产品代码及项目ID都不一样)\n在3ds上安装转换好的.cia文件\n关于如何B9S如何安装cia文件这里不再赘述(实在懒得截图了)\n大功告成~\n备注事项 据说部分老款3ds对这种方式转换的.cia支持不好，会出现黑屏情况(我的美版老小三反正测试是没问题啦) 港版不支持港版不支持港版不支持 存档类型一定要设置正确 ","date":"2020-03-30T09:00:01+08:00","image":"https://bestoko.cc/p/gba2cia/3ds_hu4bf660668473ef4591016bcd087f3f0c_132271_120x120_fill_q75_box_smart1.jpg","permalink":"https://bestoko.cc/p/gba2cia/","title":"GBA文件转CIA文件，在3ds上游玩GBA游戏的解决方案"},{"content":" Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。\nGit 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。\nGit 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。\n常用指令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 $ git init # 在当前目录新建一个 Git 代码库 $ git clone [url] # 下载一个项目和它的整个代码历史 $ git config --list # 显示当前的 Git 配置 $ git config -e [--global] # 编辑 Git 配置文件 $ git add # 添加指定文件到暂存区 $ git rm # 删除工作区文件，并且将这次删除放入暂存区 $ git commit -m [message] # 提交暂存区到仓库区 $ git commit -a # 提交工作区自上次 commit 之后的变化，直接到仓库区 $ git commit --amend -m [message] # 使用一次新的 commit，替代上一次提交 如果代码没有任何新变化，则用来改写上一次 commit 的提交信息 $ git commit --amend [file1] [file2] ... # 重做上一次 commit，并包括指定文件的新变化 # 分支相关 $ git branch # 列出所有本地分支 $ git branch -r # 列出所有远程分支 $ git branch [branch-name] # 新建一个分支，但依然停留在当前分支 $ git checkout [branch-name] # 切换到指定分支，并更新工作区 $ git checkout -b [branch] # 新建一个分支，并切换到该分支 $ git branch [branch] [commit] # 新建一个分支，指向指定 commit $ git checkout -b [branch] [tag] # 新建一个分支，指向某个 tag $ git branch --track [branch] [remote-branch] # 新建一个分支，与指定的远程分支建立追踪关系 $ git branch --set-upstream [branch] [remote-branch] # 建立追踪关系，在现有分支与指定的远程分支之间 $ git merge [branch] # 合并指定分支到当前分支 $ git cherry-pick [commit] # 选择一个 commit，合并进当前分支 $ git branch -d [branch-name] # 删除分支 $ git push origin --delete [branch-name] # 删除远程分支 $ git branch -dr [remote/branch] # 删除远程分支 # 标签 $ git tag # 列出所有 tag $ git tag [tag] # 新建一个 tag 在当前 commit $ git tag [tag] [commit] # 新建一个 tag 在指定 commit $ git show [tag] # 查看 tag 信息 $ git push [remote] [tag] # 提交指定 tag $ git push [remote] --tags # 提交所有 tag # 查看 $ git status # 显示有变更的文件 $ git log # 显示当前分支的版本历史 $ git log --stat # 显示 commit 历史，以及每次 commit 发生变更的文件 $ git log --follow [file] # 显示某个文件的版本历史，包括文件改名 $ git log -p [file] # 显示指定文件相关的每一次 diff $ git blame [file] # 显示指定文件是什么人在什么时间修改过 $ git diff # 显示暂存区和工作区的差异 $ git diff --cached [file] # 显示暂存区和上一个 commit 的差异 $ git diff HEAD # 显示工作区与当前分支最新 commit 之间的差异 $ git diff [first-branch]...[second-branch] # 显示两次提交之间的差异 $ git show [commit] # 显示某次提交的元数据和内容变化 $ git show --name-only [commit] # 显示某次提交发生变化的文件 $ git show [commit]:[filename] # 显示某次提交时，某个文件的内容 $ git reflog # 显示当前分支的最近几次提交 # 远程 $ git fetch [remote] # 下载远程仓库的所有变动 $ git remote -v # 显示所有远程仓库 $ git remote show [remote] # 显示某个远程仓库的信息 $ git remote add [shortname] [url] # 增加一个新的远程仓库，并命名 $ git pull [remote] [branch] # 取回远程仓库的变化，并与本地分支合并 $ git push [remote] [branch] # 上传本地指定分支到远程仓库 $ git push [remote] --force # 强行推送当前分支到远程仓库，即使有冲突 $ git push [remote] --all # 推送所有分支到远程仓库 # 撤销 $ git checkout [file] # 恢复暂存区的指定文件到工作区 $ git checkout [commit] [file] # 恢复某个 commit 的指定文件到工作区 $ git checkout . # 恢复上一个 commit 的所有文件到工作区 $ git reset [file] # 重置暂存区的指定文件，与上一次 commit 保持一致，但工作区不变 $ git reset --hard # 重置暂存区与工作区，与上一次 commit 保持一致 $ git reset [commit] # 重置当前分支的指针为指定 commit，同时重置暂存区，但工作区不变 $ git reset --hard [commit] # 重置当前分支的 HEAD 为指定 commit，同时重置暂存区和工作区，与指定 commit 一致 $ git reset --keep [commit] # 重置当前 HEAD 为指定 commit，但保持暂存区和工作区不变 $ git revert [commit] # 新建一个 commit，用来撤销指定 commit，后者的所有变化都将被前者抵消，并且应用到当前分支 学习资源 git - 简明指南 pro git（中文版） Git 教程 Git 参考手册 Git 指南 Learn Git Branching ","date":"2020-03-23T09:00:01+08:00","image":"https://bestoko.cc/p/gitnotes/git_logo_hu0871f2e332734283fcd708b643f05707_22105_120x120_fill_q75_box_smart1.jpg","permalink":"https://bestoko.cc/p/gitnotes/","title":"Git学习笔记"},{"content":" Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。\n以下是Markdown的基础语法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 ~~删除线~~ *斜体* _斜体第二种方法_ **加粗** __加粗的第二种方法__ ___粗斜体___ 两个enter是换行，或者用\u0026lt;/br\u0026gt;标签表示换行 用一行的=或者-表示一级标题和二级标题。如： 一级标题 ======= 二级标题 -------- 也可以在前面加上一到六个#表示标题的1级到6级，标题前加一个空格。如： # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 无序列表：在前面加上 * 或者 + 或者 - 然后加个空格： * ABC * DEF * GHI + JKL + MNO + PQR - STU - VWX - YZZ 有序列表：数字+英文句点+空格。如下： 1. 呵呵 2. 哈哈 3. 嘿嘿 4. 哼哼 \u0026amp;lt; // 会显示为”\u0026lt;“ \u0026amp;amp; // 会显示为”\u0026amp;“：在 href 属性里面，必须将 \u0026amp; 转变为 \u0026amp;amp; \\. // 为了防止产生\u0026#34;1.\u0026#34;变为有序列表，则可以写成\u0026#34;1\\.\u0026#34; * _ // 如果 * 和 _ 两边都有空白的话，它们就只会被当成普通的符号。 \u0026gt;只在整个段落的第一行最前面加上大于号可以显示引用（此时出现引用形式，并且为斜体）。但是引言内如果要断行，那个空行也必须在前面加上大于号。就像下面写的酱紫： \u0026gt;\u0026gt;区块引言也可以有级别，在前面加上不同数量的大于号即可。比如说这就是一个二级引言。 \u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt;这是一个三级引言。格式会显示为字体更小了。 建立分割线的方法有： * * * ***** - - - ------------------- 超级链接：[超级链接显示的文字](超级链接的网址，可以是绝对路径、相对路径) 也支持HTML格式的超级链接\u0026lt;a href=\u0026#34;https://www.baidu.com/\u0026#34;\u0026gt;百度\u0026lt;/a\u0026gt; 如果要标记一小段行内程序代码，可以用反引号把它包起来，像这样： Use the `printf()` function. 插入图片：![图片的替换文字](图片的地址或路径) ![风景区图片](/Snip20160202_227.png) Email邮件： \u0026lt;123456789@qq.com\u0026gt; 锚点：(能够链接到某个一级标题) [想要显示的名称](#锚点的名称) ","date":"2020-03-12T09:00:01+08:00","image":"https://bestoko.cc/p/markdwonnotes/markdown_hu593b1bacfa1a4c5df7b3aa16ecfb0c28_37213_120x120_fill_q75_box_smart1.jpg","permalink":"https://bestoko.cc/p/markdwonnotes/","title":"Markdown学习笔记"}]