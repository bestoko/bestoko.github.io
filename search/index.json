[{"content":"​\t最近刚开始刷Leetcode，第一道Hard题就难倒了我。题解里有位大神的算法很巧妙，我很容易就理解了，在此做个记录。\n 题目链接：https://leetcode-cn.com/problems/median-of-two-sorted-arrays/\n题解链接：https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/4-xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-shu/\n 题目  给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。\n请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。\n你可以假设 nums1 和 nums2 不会同时为空。\n示例 1:\n nums1 = [1, 3] nums2 = [2]\n 则中位数是 2.0 示例 2:\n nums1 = [1, 2] nums2 = [3, 4]\n 则中位数是 (2 + 3)/2 = 2.5\n 分析 首先要理解中位数  中位数（Median）又称中值，统计学中的专有名词，是按顺序排列的一组数据中居于中间位置的数，代表一个样本、种群或概率分布中的一个数值，其可将数值集合划分为相等的上下两部分。对于有限的数集，可以通过把所有观察值高低排序后找出正中间的一个作为中位数。如果观察值有偶数个，通常取最中间的两个数值的平均数作为中位数。\n  [2 3 5] 中位数是3\n[1 4 7 9] 中位数是(4+7)/2=5.5\n 割(Cut)的概念   通过切一刀，可以把有序数组分成左右两个部分，切的那一刀就被称为割(Cut)。\n  割(Cut)的左右会有两个元素，分别是左边最大值和右边最小值。\n  定义LMax= Max(LeftPart) RMin = Min(RightPart) //由小到大的有序数组\n  割可以割在2个数中间，也可以割在1个数上，如果割在一个数上，那么这个数既属于左边，也属于右边\n   奇数组: [2 3 5] 对应的中位数为3，假定割(Cut)在3上，我们可以把3分为2个： [2（3/3） 5]\n因此LMax=3, RMin=3\n偶数组: [1 4 7 9] 对应的中位数为 (4 + 7) /2 = 5.5,假定割(Cut)在4和7之间： [1 （4/7）9]\n因此LMax=4, RMin=7\n 割和第k个元素 一个数组 对于有序数组A，如果在k的位置割一下，容易得出LMax = RMin = A[k]\n两个数组 将两个数组合成一个有序数组时，第k位的元素\n 我们设: Ci为第 i个数组的割\nLMaxi为第i个数组割后的左元素i\nRMini为第i个数组割后的右元素\n    Leftpart Ci Rightpart     a1,a2,\u0026hellip;,ai / ai+1,ai+2,\u0026hellip;,am   b1,b2,\u0026hellip;,bj / bj+1,bj+2,\u0026hellip;,bn    首先，因为数组是有序的，所以LMax1 \u0026lt;= RMin1，LMax2 \u0026lt;= RMin2 //割在某个数上时左右相等\n其次，如果让LMax1 \u0026lt;= RMin2，LMax2 \u0026lt;= RMin1 呢？\n这表示左半边全部小于右半边。如果让左边的元素个数相加刚好为k，那第k个元素就是max(LMax1, Lmax2)，也就是合并后有序数组左边k个元素的最大值。\n那么如果LMax1 \u0026gt; RMin2，说明数组1的左边元素太多，我们把C1减小，C2 = k - C1相应地增大。LMax2 \u0026gt; RMin1同理，把C2减小，C1 = k - C2也就相应地增大。\n举例（设k = 3）  [2 3 5] [1 4 7 9]\n 设C1 = 1，则 C2 = k - C1 = 2 割后：\n [2 3 / 5] [1 / 4 7 9]\n 此时，LMax1 = 3, RMin1 = 5, LMax2 = 1, RMin2 = 4,\n满足 LMax1 \u0026lt; RMin2 且 LMax2 \u0026lt; RMin1 ，\n所以第3个元素为max(LMax1, LMax2) = 3\n两个数组合并后的长度问题 （本篇题解巧妙所在）  两个数组的最大问题是，它们合并后，m+n总数可能为奇, 也可能为偶，所以我们得想法让m+n总是为偶数\n通过虚拟加入‘#’，我们让m转换成2m+1 ，n转换成2n+1, 两数之和就变成了2m+2n+2，恒为偶数。\n注意是虚拟加，其实根本没这一步，通过下面的转换，我们可以保证虚拟加后每个元素跟原来的元素一一对应\n    before len after len     [1 4 7 9] 4 [# 1 # 4 # 7 # 9] 9   [2 3 5] 3 [# 2 # 3 # 5 ] 7    这么虚拟加后，每个位置可以通过/2得到原来元素的位置：\n比如 2，原来在0位，现在是1位，1/2=0\n比如 3，原来在1位，现在是3位，3/2=1\n比如 5，原来在2位，现在是5位，5/2=2\n比如 9，原来在3位，现在是7位，7/2=3\n而对于割(Cut)，如果割在‘#’上等于割在2个元素之间，割在数字上等于把数字划到2个部分，总是有以下成立：\n LMaxi = (Ci-1)/2 位置上的元素 RMini = Ci/2 位置上的元素\n 例如：\n割在3上，C = 3，LMax=a[(3-1)/2]=A[1]，RMin=a[3/2] =A[1]，刚好都是3的位置！\n割在4/7之间‘#’，C = 4，LMax=A[(4-1)/2]=A[1]=4 ，RMin=A[4/2]=A[2]=7\n剩下的事情就好办了，把2个数组看做一个虚拟的数组A，A有2m+2n+2个元素，割在m+n+1处，所以我们只需找到m+n+1位置的元素和m+n+2位置的元素就行了。\n左边：A[m+n+1] = Max(LMax1,LMax2)\n右边：A[m+n+2] = Min(RMin1,RMin2)\n==\u0026gt;Mid = (A[m+n+1]+A[m+n+2])/2 = (Max(LMax1,LMax2) + Min(RMin1,RMin2) )/2\n最快的割(Cut)是使用二分法，有2个数组，我们对哪个做二分呢？ 根据之前的分析，我们知道了，只要C1或C2确定，另外一个也就确定了。这里，为了效率，我们肯定是选长度较短的做二分，假设为C1。\nLMax1\u0026gt;RMin2，把C1减小，C2增大。—\u0026gt; C1向左二分\nLMax2\u0026gt;RMin1，把C1增大，C2减小。—\u0026gt; C1向右二分\n如果C1或C2已经到头了怎么办？ 这种情况出现在：如果有个数组完全小于或大于中值。假定n\u0026lt;m, 可能有4种情况：\nC1 = 0 —— 数组1整体都在右边了，所以都比中值大，中值在数组2中，简单的说就是数组1割后的左边是空了，所以我们可以假定LMax1 = INT_MIN\nC1 =2n —— 数组1整体都在左边了，所以都比中值小，中值在数组2中 ，简单的说就是数组1割后的右边是空了，所以我们可以假定RMin1= INT_MAX，来保证LMax2 \u0026lt; RMin1恒成立\nC2 = 0 —— 数组2整体在右边了，所以都比中值大，中值在数组1中 ，简单的说就是数组2割后的左边是空了，所以我们可以假定LMax2 = INT_MIN C2 = 2m —— 数组2整体在左边了，所以都比中值小，中值在数组1中, 简单的说就是数组2割后的右边是空了，为了让LMax1 \u0026lt; RMin2 恒成立，我们可以假定RMin2 = INT_MAX\n代码 #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;vector\u0026gt;using namespace std; #define max(a,b) (((a) \u0026gt; (b)) ? (a) : (b)) #define min(a,b) (((a) \u0026lt; (b)) ? (a) : (b))  class Solution { public: double findMedianSortedArrays(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2) { int n = nums1.size(); int m = nums2.size(); if (n \u0026gt; m) //保证数组1一定最短 \t{ return findMedianSortedArrays(nums2, nums1); } // Ci 为第i个数组的割,比如C1为2时表示第1个数组只有2个元素。LMaxi为第i个数组割后的左元素。RMini为第i个数组割后的右元素。 \tint LMax1, LMax2, RMin1, RMin2, c1, c2, lo = 0, hi = 2 * n; //我们目前是虚拟加了\u0026#39;#\u0026#39;所以数组1是2*n长度 \twhile (lo \u0026lt;= hi) //二分 \t{ c1 = (lo + hi) / 2; //c1是二分的结果 \tc2 = m + n - c1; LMax1 = (c1 == 0) ? INT_MIN : nums1[(c1 - 1) / 2]; RMin1 = (c1 == 2 * n) ? INT_MAX : nums1[c1 / 2]; LMax2 = (c2 == 0) ? INT_MIN : nums2[(c2 - 1) / 2]; RMin2 = (c2 == 2 * m) ? INT_MAX : nums2[c2 / 2]; if (LMax1 \u0026gt; RMin2) hi = c1 - 1; else if (LMax2 \u0026gt; RMin1) lo = c1 + 1; else break; } return (max(LMax1, LMax2) + min(RMin1, RMin2)) / 2.0; } }; int main(int argc, char *argv[]) { vector\u0026lt;int\u0026gt; nums1 = { 2,3, 5 }; vector\u0026lt;int\u0026gt; nums2 = { 1,4,7, 9 }; Solution solution; double ret = solution.findMedianSortedArrays(nums1, nums2); return 0; } ","date":"2020-04-10T00:00:00Z","permalink":"https://bestoko.github.io/p/leetcode004/","title":"寻找两个有序数组的中位数"},{"content":"前情提要 为什么要水这么一篇文章\n在把switch借给朋友玩的这段时间，我把目光投向了吃灰已久的3ds\u0026hellip;.\n我想要在实机上游玩gba游戏，但是3ds上的模拟器又有各种各样的兼容性问题，达不到eshop里VC金银流畅的游玩体验；宣称能游玩GBA的DSTWO PLUS烧录卡早已停产，某宝/闲鱼的价格居高不下\u0026hellip;经过一番摸索，我找到了可能是现今最好的解决方案。\n准备工作   一台BOOT9STARP(B9S)破解的3ds\n参考3ds破解手册或者一只火狐大佬整理的教程(推荐)\n嫌麻烦的同学可以交给热心摊主处理\n  Ultimate GBA VC Injector for 3DS\n  汉化版下载链接\n  你想要在3ds上运行的GBA游戏ROM文件\n这里以漆黑的魅影为例（很棒的GBA宝可梦改版，我一直想在实机上玩）\n  GBA 转CIA  打开软件并导入下载好的.gba文件，ROM大小和存档类型会自动确认(汉化版ROM往往是数据库未找到该游戏，请确保选择的正确无误以免影响存档)   gba2cia1 \n gba2cia2 \n 填写要转换的VC图标和名称(因为3ds字库的原因建议不要使用中文XD)，设置3D横幅(就是选中这个游戏时3ds上屏的画面)\n gba2cia3 \n gba2cia4 \n  设置VC参数并导出CIA文件(注意当转换多个.cia文件时，确保每个文件的产品代码及项目ID都不一样)\n gba2cia5 \n  在3ds上安装转换好的.cia文件\n  关于如何B9S如何安装cia文件这里不再赘述(实在懒得截图了)\n gba2cia6 \n大功告成~\n备注事项  据说部分老款3ds对这种方式转换的.cia支持不好，会出现黑屏情况(我的美版老小三反正测试是没问题啦) 港版不支持港版不支持港版不支持 存档类型一定要设置正确  ","date":"2020-03-30T00:00:00Z","image":"https://bestoko.github.io/p/gba2cia/gba2cia6_hu4cb3b5259b7551644a7156ad5f6a4c56_716178_120x120_fill_box_smart1_3.png","permalink":"https://bestoko.github.io/p/gba2cia/","title":"GBA文件转CIA文件，在3ds上游玩GBA游戏的解决方案"},{"content":" Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。\nGit 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。\nGit 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。\n  learnGit \n常用指令 $ git init # 在当前目录新建一个 Git 代码库 $ git clone [url] # 下载一个项目和它的整个代码历史 $ git config --list # 显示当前的 Git 配置 $ git config -e [--global] # 编辑 Git 配置文件 $ git add # 添加指定文件到暂存区 $ git rm # 删除工作区文件，并且将这次删除放入暂存区 $ git commit -m [message] # 提交暂存区到仓库区 $ git commit -a # 提交工作区自上次 commit 之后的变化，直接到仓库区 $ git commit --amend -m [message] # 使用一次新的 commit，替代上一次提交 如果代码没有任何新变化，则用来改写上一次 commit 的提交信息 $ git commit --amend [file1] [file2] ... # 重做上一次 commit，并包括指定文件的新变化 # 分支相关 $ git branch # 列出所有本地分支 $ git branch -r # 列出所有远程分支 $ git branch [branch-name] # 新建一个分支，但依然停留在当前分支 $ git checkout [branch-name] # 切换到指定分支，并更新工作区 $ git checkout -b [branch] # 新建一个分支，并切换到该分支 $ git branch [branch] [commit] # 新建一个分支，指向指定 commit $ git checkout -b [branch] [tag] # 新建一个分支，指向某个 tag $ git branch --track [branch] [remote-branch] # 新建一个分支，与指定的远程分支建立追踪关系 $ git branch --set-upstream [branch] [remote-branch] # 建立追踪关系，在现有分支与指定的远程分支之间 $ git merge [branch] # 合并指定分支到当前分支 $ git cherry-pick [commit] # 选择一个 commit，合并进当前分支 $ git branch -d [branch-name] # 删除分支 $ git push origin --delete [branch-name] # 删除远程分支 $ git branch -dr [remote/branch] # 删除远程分支 # 标签 $ git tag # 列出所有 tag $ git tag [tag] # 新建一个 tag 在当前 commit $ git tag [tag] [commit] # 新建一个 tag 在指定 commit $ git show [tag] # 查看 tag 信息 $ git push [remote] [tag] # 提交指定 tag $ git push [remote] --tags # 提交所有 tag # 查看 $ git status # 显示有变更的文件 $ git log # 显示当前分支的版本历史 $ git log --stat # 显示 commit 历史，以及每次 commit 发生变更的文件 $ git log --follow [file] # 显示某个文件的版本历史，包括文件改名 $ git log -p [file] # 显示指定文件相关的每一次 diff $ git blame [file] # 显示指定文件是什么人在什么时间修改过 $ git diff # 显示暂存区和工作区的差异 $ git diff --cached [file] # 显示暂存区和上一个 commit 的差异 $ git diff HEAD # 显示工作区与当前分支最新 commit 之间的差异 $ git diff [first-branch]...[second-branch] # 显示两次提交之间的差异 $ git show [commit] # 显示某次提交的元数据和内容变化 $ git show --name-only [commit] # 显示某次提交发生变化的文件 $ git show [commit]:[filename] # 显示某次提交时，某个文件的内容 $ git reflog # 显示当前分支的最近几次提交 # 远程 $ git fetch [remote] # 下载远程仓库的所有变动 $ git remote -v # 显示所有远程仓库 $ git remote show [remote] # 显示某个远程仓库的信息 $ git remote add [shortname] [url] # 增加一个新的远程仓库，并命名 $ git pull [remote] [branch] # 取回远程仓库的变化，并与本地分支合并 $ git push [remote] [branch] # 上传本地指定分支到远程仓库 $ git push [remote] --force # 强行推送当前分支到远程仓库，即使有冲突 $ git push [remote] --all # 推送所有分支到远程仓库 # 撤销 $ git checkout [file] # 恢复暂存区的指定文件到工作区 $ git checkout [commit] [file] # 恢复某个 commit 的指定文件到工作区 $ git checkout . # 恢复上一个 commit 的所有文件到工作区 $ git reset [file] # 重置暂存区的指定文件，与上一次 commit 保持一致，但工作区不变 $ git reset --hard # 重置暂存区与工作区，与上一次 commit 保持一致 $ git reset [commit] # 重置当前分支的指针为指定 commit，同时重置暂存区，但工作区不变 $ git reset --hard [commit] # 重置当前分支的 HEAD 为指定 commit，同时重置暂存区和工作区，与指定 commit 一致 $ git reset --keep [commit] # 重置当前 HEAD 为指定 commit，但保持暂存区和工作区不变 $ git revert [commit] # 新建一个 commit，用来撤销指定 commit，后者的所有变化都将被前者抵消，并且应用到当前分支 学习资源  git - 简明指南 pro git（中文版） Git 教程 Git 参考手册 Git 指南 Learn Git Branching  ","date":"2020-03-23T00:00:00Z","image":"https://bestoko.github.io/p/gitnotes/learnGit_hu6c00e95ffa94d0d773fe80624b67f967_105681_120x120_fill_box_smart1_3.png","permalink":"https://bestoko.github.io/p/gitnotes/","title":"Git学习笔记"},{"content":" Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。\n 以下是Markdown的基础语法\n~~删除线~~ *斜体* _斜体第二种方法_ **加粗** __加粗的第二种方法__ ___粗斜体___ 两个enter是换行，或者用\u0026lt;/br\u0026gt;标签表示换行 用一行的=或者-表示一级标题和二级标题。如： 一级标题 ======= 二级标题 -------- 也可以在前面加上一到六个#表示标题的1级到6级，标题前加一个空格。如： # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题  无序列表：在前面加上 * 或者 + 或者 - 然后加个空格： * ABC * DEF * GHI + JKL + MNO + PQR - STU - VWX - YZZ 有序列表：数字+英文句点+空格。如下： 1. 呵呵 2. 哈哈 3. 嘿嘿 4. 哼哼 \u0026amp;lt; // 会显示为”\u0026lt;“ \u0026amp;amp; // 会显示为”\u0026amp;“：在 href 属性里面，必须将 \u0026amp; 转变为 \u0026amp;amp; \\. // 为了防止产生\u0026#34;1.\u0026#34;变为有序列表，则可以写成\u0026#34;1\\.\u0026#34; * _ // 如果 * 和 _ 两边都有空白的话，它们就只会被当成普通的符号。 \u0026gt;只在整个段落的第一行最前面加上大于号可以显示引用（此时出现引用形式，并且为斜体）。但是引言内如果要断行，那个空行也必须在前面加上大于号。就像下面写的酱紫： \u0026gt;\u0026gt;区块引言也可以有级别，在前面加上不同数量的大于号即可。比如说这就是一个二级引言。 \u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt;这是一个三级引言。格式会显示为字体更小了。 建立分割线的方法有： * * * ***** - - - ------------------- 超级链接：[超级链接显示的文字](超级链接的网址，可以是绝对路径、相对路径) 也支持HTML格式的超级链接\u0026lt;a href=\u0026#34;https://www.baidu.com/\u0026#34;\u0026gt;百度\u0026lt;/a\u0026gt; 如果要标记一小段行内程序代码，可以用反引号把它包起来，像这样： Use the `printf()` function. 插入图片：![图片的替换文字](图片的地址或路径) ![风景区图片](/Snip20160202_227.png) Email邮件： \u0026lt;123456789@qq.com\u0026gt; 锚点：(能够链接到某个一级标题) [想要显示的名称](#锚点的名称) ","date":"2020-03-12T00:00:00Z","permalink":"https://bestoko.github.io/p/markdwonnotes/","title":"Markdown学习笔记"}]