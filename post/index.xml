<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Toko&#39;s blog</title>
    <link>https://bestoko.cc/post/</link>
    <description>Recent content in Posts on Toko&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 08 Mar 2022 20:56:36 +0800</lastBuildDate><atom:link href="https://bestoko.cc/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Ubuntu 20.04 终端插件配置与美化</title>
      <link>https://bestoko.cc/p/zsh/</link>
      <pubDate>Tue, 08 Mar 2022 20:56:36 +0800</pubDate>
      
      <guid>https://bestoko.cc/p/zsh/</guid>
      <description>​	对 Linux 用户来说, 一个美观方便的终端可以提高很多工作效率.我所推荐的终端方案是 zsh + oh-my-zsh + Powerlevel10k ,兼顾美观与高效. 我所在的公司开发环境是 Ubuntu 20.04 , 本文就以这此发行版为例进行配置.
Zsh 安装 zsh
sudo apt install zsh 将 zsh 设置为默认 shell
chsh -s /bin/zsh 你可以用echo $SHELL 指令来查看当前的默认 shell 是否修改成功.
oh-my-zsh 安装 oh-my-zsh
sh -c &amp;#34;$(curl -fsSL https://gitee.com/shmhlsy/oh-my-zsh-install.sh/raw/master/install.sh)&amp;#34; 安装一些实用插件
#自动补齐 git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh}/plugins/zsh-autosuggestions #语法高亮 git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh}/plugins/zsh-syntax-highlighting #自动跳转 sudo apt-get install autojump 配置插件
vim ~/.zshrc #在 plugins 行添加插件名,如: plusgins=(git zsh-autosuggestions zsh-syntax-highlighting) #最后一行添加 . /usr/share/autojump/autojump.</description>
    </item>
    
    <item>
      <title>Arch Linux与Win11双系统修复grub引导</title>
      <link>https://bestoko.cc/p/grubfix/</link>
      <pubDate>Sat, 05 Mar 2022 19:19:15 +0800</pubDate>
      
      <guid>https://bestoko.cc/p/grubfix/</guid>
      <description>自用的电脑是Arch Linux和windows10双系统, 今天想着把win10抹掉装win11, 装完后从grub引导界面无法进入windows, 才想起来忘记考虑引导的事情了.
下面给出一个简单的解决办法:
sudo pacman -S prober 安装 os-prober , 这个工具可以帮助自动发现包含windows的分区
(如果你的windows分区启用了bitlocker, 你可能还需要先使用dislocker)
接着:
sudo grub-mkconfig -o /boot/grub/grub.cfg 利用 grub-mkconfig 探测其他已经安装的系统并自动把他们添加到启动菜单.
 如果你得到以下输出：Warning: os-prober will not be executed to detect other bootable partitions，你需要编辑/etc/default/grub并取消下面这一行的注释，如果没有相应注释的话就在文件末尾添加上：
GRUB_DISABLE_OS_PROBER=false  </description>
    </item>
    
    <item>
      <title>Android平台架构学习笔记</title>
      <link>https://bestoko.cc/p/android-framework/</link>
      <pubDate>Thu, 03 Mar 2022 20:00:00 +0800</pubDate>
      
      <guid>https://bestoko.cc/p/android-framework/</guid>
      <description>平台架构  
https://developer.android.com/guide/platform?hl=zh-cn
从下到上依次分为：
 Linux内核层 硬件抽象层 HAL 系统运行库层 Java API 框架 系统应用  每一层都包含大量的子模块或子系统。
Linux内核层 (Linux Kernel)  Android 平台的基础是 Linux 内核。例如，Android Runtime (ART) 依靠 Linux 内核来执行底层功能，例如线程和低层内存管理。
使用 Linux 内核可让 Android 利用主要安全功能，并且允许设备制造商为著名的内核开发硬件驱动程序。
 Android平台以Linux内核为基础，避开了直接与硬件打交道，为驱动开发提供了高度扩展性和易用性，大大降低了 Android 系统移植工作的难度。
硬件抽象层 (Hardware Abstract Layer,HAL)  硬件抽象层 (HAL) 提供标准界面，向更高级别的 Java API 框架显示设备硬件功能。HAL 包含多个库模块，其中每个模块都为特定类型的硬件组件实现一个界面，例如相机或蓝牙模块。当框架 API 要求访问设备硬件时，Android 系统将为该硬件组件加载库模块。
 Linux内核层与HAL层共同实现了对硬件的支持。其中HAL层运行在用户空间(User Space)，而Linux内核驱动程序运行在内核空间(Kernel Space)。为什么不把它们整合起来放到内核空间呢？技术角度是可以实现的，然而商业角度上会损害硬件厂商的利益。Linux内核源代码版权遵循GNU License(发布产品时必须公布源代码)，而Android源代码版权遵循Apache License(发布产品时无须公布源代码)。
也就是说，Android放在内核空间的驱动程序对硬件的支持是不完整的，因此被踢出Linux内核主线代码树。
系统运行库层 这一层中包含了支撑整个系统正常运行的基础库，由系统类库和Android运行时组成。由于这些库多数由C/C++实现，因此也被一些开发人员称为“C库层”，以区别应用程序框架层。
原生 C/C++ 库 (Native C/C++ Libraries)  许多核心 Android 系统组件和服务(例如 ART 和 HAL)构建自原生代码，需要以 C 和 C++ 编写的原生库。Android 平台提供 Java 框架 API 以向应用显示其中部分原生库的功能。例如，您可以通过 Android 框架的 Java OpenGL API 访问 OpenGL ES，以支持在应用中绘制和操作 2D 和 3D 图形。</description>
    </item>
    
    <item>
      <title>我的Linux科学上网方案</title>
      <link>https://bestoko.cc/p/linux-clash-for-windows/</link>
      <pubDate>Wed, 05 Jan 2022 11:59:35 +0800</pubDate>
      
      <guid>https://bestoko.cc/p/linux-clash-for-windows/</guid>
      <description>写在前面  本文不讨论科学上网的对错 本文不教学代理服务器部署 本文不推荐任何机场  Linux平台有很多成熟可靠的科学上网工具，本文仅列出我所推荐使用的，其余方案请自行搜索。
Clash for windows Clash 是一个使用 Go 语言编写，基于规则的跨平台代理软件核心程序。 Clash for Windows (cfw)是一个Windows/macOS/Linux下的clash图形化客户端。 支持的协议： Vmess, Shadowsocks, Snell , Sock5 , ShadowsocksR
安装 你可以直接从cfw的github页下载解压使用，也可以通过flatpak来安装在你所需要的任何Linux系统上。
 Flatpak是一个类似snap的程序包管理程序，要使用Flatpak软件包，你的Linux发行版必须具有Flatpak支持。
某些发行版（如Fedora Solus）默认情况下都具有Flatpak支持.
 以Arch Linux为例安装Flatpak。
sudo pacman -S flatpak  [注]如果只为了使用cfw的话，其实Arch Linux不必多次一举，AUR上已经有人打包好了。
yay -S clash-for-windows-bin  安装cfw
flatpak install flathub io.github.Fndroid.clash_for_windows 配置 打开 Clash for Windows ，在左侧的标签页选择Profiles， 在顶部输入 Clash 订阅链接 ，然后点击Download按钮。
Clash for Windows 会自动拉取配置文件进行更新，如果一切顺利，你应当可以看到绿色提示信息Success!，并且可以看到一个新增的配置文件。
点击新增的配置文件来切换到该配置，然后点击Proxies 标签页来切换接入点，将顶部的出站模式选择为Rule。 此模式下你的网络访问请求将通过 Clash for Windows 进行分流处理。</description>
    </item>
    
    <item>
      <title>Gnome农历插件安装踩坑记录</title>
      <link>https://bestoko.cc/p/gnome-lunar-calendar/</link>
      <pubDate>Thu, 30 Dec 2021 09:18:46 +0800</pubDate>
      
      <guid>https://bestoko.cc/p/gnome-lunar-calendar/</guid>
      <description>在extensions.gnome.org上找到个农历扩展Lunar Calendar 农历，直接安装会因为缺少依赖报错，搜到的rpm包也无法正常安装，查了下需要手动编译安装lunar-date。
Fedora35 编译安装lunar-date github页给的安装指南如下
meson build --prefix /usr -Ddocs=true -Dintrospection=true -Dvapi=true -Dtests=true ninja -C build/ sudo ninja -C build install  meson是用Python语言开发的构建工具，编译需要Ninja（用C++实现）命令。
 所以首先
sudo dnf install meson ninja-build 接着运行指南上第一条指令，如果有依赖缺失会报错，但是提示的依赖名称不能直接用于dnf install,可以在command-not-found.com 查询所需安装指令。以我为例：
sudo dnf install vala gtk-doc 接着重新安装插件就可以正常启用了。
额外可选设置 默认情况下当系统语言为中文时扩展可以正常工作，但是像我一样习惯系统语言用英文的话，农历会以拼音形式标注出来（真的很难看），解决办法如下：
cp /usr/share/locale/zh_CN/LC_MESSAGES/lunar-date.mo /usr/share/locale/en_US/LC_MESSAGES/lunar-date.mo  效果展示</description>
    </item>
    
    <item>
      <title>Grub2主题美化踩坑记录</title>
      <link>https://bestoko.cc/p/fedora-grub2-theme/</link>
      <pubDate>Wed, 29 Dec 2021 18:56:18 +0800</pubDate>
      
      <guid>https://bestoko.cc/p/fedora-grub2-theme/</guid>
      <description>双系统用了一段时间后，开机黑洞洞的grub界面自然看着不爽 （虽然只有几秒）,于是想着去美化一下，其中遇到了点小坑，记录一下。使用的机器装了Windows11和Fedora35。
下载主题 首先下载好你想要的主题文件，我选择的是这个MacOS风格的MacOS Monterey inspired grub theme
 展示效果 
修改/etc/default/grub文件 首先，注释掉GRUB_TERMINAL_OUTPUT=”console”,接着设置好你的GRUB主题路径。
#GRUB_TERMINAL_OUTPUT=”console” GRUB_THEME=&amp;#34;/boot/grub2/montery-grub-theme/theme.txt&amp;#34;  此外这个文件里还有几个常用的设置 GRUB_TIMEOUT=5 可以设置超时时间，设置-1可以取消倒计时 GRUB_DEFAULT=saved saved：光标会默认选择上一个成功进入的启动项，也可以填入数字，以指定启动列表中第x项为启动项，x从0开始计数
 更新Grub2配置 如果跟我一样使用GPT分区，以UEFI启动方式的话，启动时读取的位置是/boot/efi/EFI/fedora/grub.cfg ，更新命令如下：
sudo grub2-mkconfig -o /boot/efi/EFI/fedora/grub.cfg 而如果是启动方式是Legacy的话，启动时读取的文件是/boot/grub2/grub.cfg，更新命令如下：
sudo grub2-mkconfig -o /boot/grub2/grub.cfg 接着reboot即可看到效果。</description>
    </item>
    
    <item>
      <title>Linux上VirtualBox启动时sbin/vboxconfig错误的解决办法</title>
      <link>https://bestoko.cc/p/linux-virtualbox-error/</link>
      <pubDate>Tue, 28 Dec 2021 11:21:20 +0800</pubDate>
      
      <guid>https://bestoko.cc/p/linux-virtualbox-error/</guid>
      <description>在 Arch Linux 上使用 Virtual Box 制作虚拟机，打开时却出了问题。
报错信息  Kernel driver not installed (rc=-1908)
  error 
VirtualBox Linux 内核驱动程序未加载或未正确设置。
解决办法 执行如下命令，重新安装vboxdrv模块
sudo modprobe vboxdrv 如果不起作用，检查下是否在BIOS/UEFI设置中禁用安全启动（Secure Boot），因为安全启动会阻止加载未签名的模块。</description>
    </item>
    
    <item>
      <title>Linux与Windows双系统时间不一致的解决方法</title>
      <link>https://bestoko.cc/p/linux-windows-time-conflict/</link>
      <pubDate>Mon, 27 Dec 2021 21:14:01 +0800</pubDate>
      
      <guid>https://bestoko.cc/p/linux-windows-time-conflict/</guid>
      <description>给常用的电脑加了块固态装了Arch linux，结果在切换双系统时出现两个系统时间不一致的现象，是我之前在Surface上单系统所没遇到的。
为什么时间不一致  这是因为BIOS硬件时间本身并没有时区概念，但Windows和Linux对Bios硬件时间与时区关系的理解不一样。Linux将BIOS硬件时间视为协调世界时（UTC），即不存在本地时区；而Windows则将BIOS硬件时间视为当地时间，带上了设置后的时区。Windows这样做，一是早期为了兼容MS-DOS/Windows 3.x，二是为了照顾大众，防止用户问为什么BIOS显示的时间和实际不一致。
中国大陆、中国香港、中国澳门、中国台湾、蒙古国、新加坡、马来西亚、菲律宾、西澳大利亚州的时间与UTC的时差均为+8，也就是UTC+8。
 推荐的解决办法 Windows 其实也能处理 UTC，需要修改注册表。建议让 Windows 使用 UTC，而非让 Linux 使用地方时。Windows 使用 UTC 后，请记得禁用 Windows 的时间同步功能，以防 Windows 错误设置硬件时间。
Linux 可以使用NTP服务来在线同步硬件时钟。
使用 regedit,新建如下 DWORD 值，并将其值设为十六进制的 1。
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\TimeZoneInformation\RealTimeIsUniversal 也可以用管理员权限启动命令行来完成：
reg add &amp;#34;HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\TimeZoneInformation&amp;#34; /v RealTimeIsUniversal /d 1 /t REG_DWORD /f 如果以上操作不起作用，并且你使用的是 Windows 64位系统，将 DWORD 修改为 QWORD。
参考：https://wiki.archlinux.org/index.php/System_time#UTC_in_Windows</description>
    </item>
    
    <item>
      <title>Arch Linux上借助Snaps安装MicroSoft To-Do(unofficial)</title>
      <link>https://bestoko.cc/p/snaps-mstodo/</link>
      <pubDate>Wed, 22 Dec 2021 01:15:01 +0800</pubDate>
      
      <guid>https://bestoko.cc/p/snaps-mstodo/</guid>
      <description>虽然我一直不觉得自己是软粉，但是不知不觉中M$家的产品越用越顺手了。
MicroSoft To-Do作为代办清单app来说，简洁实用，同步方便，而最近在适应Arch Linux的我，实在用不惯gnome桌面自带的ToDo，必须想办法换回去。
 Snaps安装与配置  snap是Canonical公司发布的全新的软件包管理方式，它类似一个容器拥有一个应用程序所有的文件和库，各个应用程序之间完全独立。所以使用snap包的好处就是它解决了应用程序之间的依赖问题，使应用程序之间更容易管理。但是由此带来的问题就是它占用更多的磁盘空间。
 也就是说，对于生态系统碎片化严重的Linux来说，Snaps像是它们的中间地带，不管运行哪种Linux分支，都能轻易通过Snaps获取想要的应用程序包。
安装Snap软件包 首先，赞美AUR，snapd及其依赖包snap-confine和squashfs-tools都在仓库里了。
sudo pacman -S snapd 启动守护进程 sudo systemctl enable --now snapd.socket 启用classic snap support sudo ln -s /var/lib/snapd/snap /snap 接着log out或者reboot一下来确保snap的路径正确更新。
 Strict
Used by the majority of snaps. Strictly confined snaps run in complete isolation, up to a minimal access level that’s deemed always safe. Consequently, strictly confined snaps can not access your files, network, processes or any other system resource without requesting specific access via an interface (see below).</description>
    </item>
    
    <item>
      <title>Arch Linux上修改Code-OSS扩展源</title>
      <link>https://bestoko.cc/p/code-oss-extensions/</link>
      <pubDate>Mon, 20 Dec 2021 09:00:01 +0800</pubDate>
      
      <guid>https://bestoko.cc/p/code-oss-extensions/</guid>
      <description> 类比于Chrome 浏览器和其开源的“上游”项目 Chromium。VS Code 确实是基于开源代码库构建的。而微软官方发布的版本带有一些与微软相关的功能，包括一项商标、一个插件库、一个 C# 调试器以及遥测。但如果你克隆仓库然后自行编译，这些东西都不会被加入，所以你会得到一个名为 Code - OSS 的“干净”版本（OSS，Open-source software ）。
 我之前使用
pacman -S code 所安装的正是Code-OSS ，默认不使用微软官方扩展市场。
方法一 我们可以通过修改/usr/lib/code/product.json解决这个问题，添加如下内容：
&amp;#34;extensionsGallery&amp;#34;: { &amp;#34;serviceUrl&amp;#34;: &amp;#34;https://marketplace.visualstudio.com/_apis/public/gallery&amp;#34;, &amp;#34;cacheUrl&amp;#34;: &amp;#34;https://vscode.blob.core.windows.net/gallery/index&amp;#34;, &amp;#34;itemUrl&amp;#34;: &amp;#34;https://marketplace.visualstudio.com/items&amp;#34; } 重新启动Code-OSS就可以了。
方法二 方法一正常使用一段时间后，在某次重启后出现打不开Code-OSS的情况，所幸从AUR上找到了另一个包解决了问题，记录在此。
yay -S code-marketplace </description>
    </item>
    
    <item>
      <title>Surface设备在Arch Linux下驱动问题的解决方案</title>
      <link>https://bestoko.cc/p/surface-linux/</link>
      <pubDate>Thu, 16 Dec 2021 01:48:01 +0800</pubDate>
      
      <guid>https://bestoko.cc/p/surface-linux/</guid>
      <description>写在前面 之前我已经在Surface Pro 上安装了Arch Linux，可是由简入奢易，由奢入艰难，习惯了的二合一设备突然不能正常触屏还是有些不爽（之前买的surface pen也成了摆设），于是我在github上找到了第三方内核。由于是第三方内核，各设备各硬件的适配情况并不完善，具体可以查看这里。
安装驱动 导入密钥 首先我们需要导入用于签名软件包的密钥：
$ curl -s https://raw.githubusercontent.com/linux-surface/linux-surface/master/pkg/keys/surface.asc \  | sudo pacman-key --add - 检查完整性并本地签名 $ sudo pacman-key --finger 56C464BAAC421453 $ sudo pacman-key --lsign-key 56C464BAAC421453 添加存储库 我们需要在/etc/pacman.conf添加如下内容
[linux-surface] Server = https://pkg.surfacelinux.com/arch/ 更新存储库数据，安装内核，启用服务 我们需要更新存储库数据，以安装linux-surface内核及其依赖项，接着启用iptsd服务以使用触摸屏。
$ sudo pacman -Syu $ sudo pacman -S linux-surface linux-surface-headers iptsd $ sudo systemctl enable iptsd 重启以后就完工了，屏幕触摸也支持了。</description>
    </item>
    
    <item>
      <title>Arch Linux安装备忘录（二）</title>
      <link>https://bestoko.cc/p/archinstallextra/</link>
      <pubDate>Wed, 15 Dec 2021 09:00:01 +0800</pubDate>
      
      <guid>https://bestoko.cc/p/archinstallextra/</guid>
      <description>写在前面 在安装了基本的ArchLinux后，我们还需要一些配置、安装一些组件，来扩展系统功能，使其更符合我们日常使用习惯。
配置网络 我们使用
nmtui 选择Edit a connection，
选择Add菜单，选择WI-FI，
Device 里输入 无线网卡的名字，SSID里输入WI-FI的名字，Security选择WPA &amp;amp;WPA2 Personal，OK-BACK-Quit退出。
注：使用以下命令查看无线网卡名称
ip link show 重命名主机 vim /etc/hostname 保存想要的名字后退出。
接下来把主机名、域名以及ip地址进行映射
vim /etc/hosts 输入：(以下archlinux为上文所保存的主机名)
127.0.0.1	localhost ::1	localhost 127.0.0.1 archlinux.localdomain	archlinux 设置系统时间 timedatectl set-timezone Asia/shanghai timedatectl set-ntp true 第二行设置为让本机时间与ntp同步。
配置环境变量 vim /etc/skel/.bashrc 添加以下内容
export EDITOR=vim alias grep=&amp;#39;grep ==color=auto&amp;#39; alias egrep=&amp;#39;egrep ==color=auto&amp;#39; alias fgrep=&amp;#39;fgrep ==color=auto&amp;#39; [ ！ -e ~/.dircolors ] &amp;amp;&amp;amp; eval $(dircolors -p &amp;gt; ~/.dircolors) [ ！ -e /bin/dircolors ] &amp;amp;&amp;amp; eval $(dircolors -b &amp;gt; ~/.</description>
    </item>
    
    <item>
      <title>Arch Linux安装备忘录（一）</title>
      <link>https://bestoko.cc/p/archinstall/</link>
      <pubDate>Tue, 14 Dec 2021 09:00:01 +0800</pubDate>
      
      <guid>https://bestoko.cc/p/archinstall/</guid>
      <description>写在前面 安装Arch最好最全面的教程就是官方的 Installation guide。但是Wiki上的介绍更偏向文档，而不是新手习惯的那种按步骤编排的教程，加上中文Wiki的翻译往往落后于英文版，缺乏预备Linux知识的新手经常无从下手。
笔者也是初学者，本篇文章仅作为自己在Surface Pro 2017从0开始安装配置Arch的记录。
安装准备 磁盘准备 我们需要准备一块有空闲区域（没有被分区）的磁盘留给系统的安装。笔者只准备安装Arch单系统，因此在PE里用磁盘管理工具把Surface的磁盘0各个分区全部删除。你也可以在Windows下找到磁盘管理，自行划分一个区域留给安装使用。
安装介质 https://www.archlinux.org/download/ 建议从下面的中国镜像下载iso文件
https://rufus.ie/ 我们用Rufus来制作引导盘，此步需要用到一个空闲U盘。需要注意的是写入方式选择DD，分区类型选择GPT而非默认的MBR。
设置启动顺序 接下来需要进入个人电脑的BIOS里把制作的U盘启动设置为第一位，笔者的Surface额外需要先关闭security boot，不同电脑进入BIOS的按键略有不同，Surface是开机键和音量+键，其他型号电脑请查阅搜索引擎。
安装过程 正确设置好启动顺序后，启动时会看到ArchLinux的界面，按Enter键选择 Boot Arch Linux ，等待加载完成后会进入一个有命令提示符的界面。我们接下来将在这个界面执行一系列命令来讲Arch安装到之前准备的磁盘上。
*网络连接 Arch的安装需要联网，如果你使用的是有线连接，可以跳过此部分，笔者这里使用无线连接继续安装。
输入
iwctl 进入iwd模式，输入
device list 查看你的网卡名字，这里假设是wlan0，输入
station wlan0 scan 检查扫描网络，输入
station wlan0 get-networks 查看网络名字，假设名字叫XXX，输入
station wlan0 connect XXX 接着输入密码（如果有密码的话），输入
exit 退出iwd模式
我们可以用ping命令来检验下是否连接成功
ping -c 4 baidu.com 接下来我们需要让安装介质里的数据库保持与官方一致的最新版本，因此需要同步一下，在此之前，我们可以配置下最新的镜像来保证下载速度。
reflector --country China --age 24 --sort rate --portocol https --save /etc/pacman.d/mirrorlist  country 限定国家 age 24 限定下更新时间为24小时内的源 portocol https 选择https协议更安全  执行完毕后，可以用vim查看</description>
    </item>
    
    <item>
      <title>一加8的Android 11 折腾指南</title>
      <link>https://bestoko.cc/p/oneplus8/</link>
      <pubDate>Wed, 28 Oct 2020 09:00:01 +0800</pubDate>
      
      <guid>https://bestoko.cc/p/oneplus8/</guid>
      <description>准备工作   解锁Bootloader且打开USB调试的一加8
  氢OS Android11 Rom包
  Payload Dumber
  platform-tools
打包下载： pan.baidu.com/s/1afSr1snXan4LoBLX9l0Urg 【pcge】
  刷入Magisk 制作magisk_patched.img   将官方包内的payload.bin 解压并放入Payload Dumber 的payload_input目录
  打开payload_dumper.exe（看到boot解压出来就可以关闭了）
  打开payload_output目录，将解压出的boot.img复制到手机根目录
  下载并安装Magisk最新版本 (https://github.com/topjohnwu/Magisk/releases)
选择安装Magisk-选择并修补一个文件，选中放在根目录的boot.img ，等待修补完成
  将手机download目录下的修补完成的magisk_patched.img复制到电脑
  工具刷入mgisk_patched.img   将mgisk_patched.img放入 platform-tools 目录下
  运行
打开CMD命令行.bat  adb reboot bootloader fastboot flash boot_a magisk_patched.img fastboot flash boot_b magisk_patched.img fastboot reboot    刷入EdXposed  刷入Riru - Core模块 刷入Riru - EdXposed(YAHFA) 或Riru - EdXposed(SandHook)模块 安装最新的Edxposed Manager  总结与注意事项   制作mgisk_patched.</description>
    </item>
    
    <item>
      <title>寻找两个有序数组的中位数</title>
      <link>https://bestoko.cc/p/leetcode004/</link>
      <pubDate>Fri, 10 Apr 2020 09:00:01 +0800</pubDate>
      
      <guid>https://bestoko.cc/p/leetcode004/</guid>
      <description>​	最近刚开始刷Leetcode，第一道Hard题就难倒了我。题解里有位大神的算法很巧妙，我很容易就理解了，在此做个记录。
 题目链接：https://leetcode-cn.com/problems/median-of-two-sorted-arrays/
题解链接：https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/4-xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-shu/
 题目  给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。
请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。
你可以假设 nums1 和 nums2 不会同时为空。
示例 1:
 nums1 = [1, 3] nums2 = [2]
 则中位数是 2.0 示例 2:
 nums1 = [1, 2] nums2 = [3, 4]
 则中位数是 (2 + 3)/2 = 2.5
 分析 首先要理解中位数  中位数（Median）又称中值，统计学中的专有名词，是按顺序排列的一组数据中居于中间位置的数，代表一个样本、种群或概率分布中的一个数值，其可将数值集合划分为相等的上下两部分。对于有限的数集，可以通过把所有观察值高低排序后找出正中间的一个作为中位数。如果观察值有偶数个，通常取最中间的两个数值的平均数作为中位数。
  [2 3 5] 中位数是3
[1 4 7 9] 中位数是(4+7)/2=5.</description>
    </item>
    
    <item>
      <title>GBA文件转CIA文件，在3ds上游玩GBA游戏的解决方案</title>
      <link>https://bestoko.cc/p/gba2cia/</link>
      <pubDate>Mon, 30 Mar 2020 09:00:01 +0800</pubDate>
      
      <guid>https://bestoko.cc/p/gba2cia/</guid>
      <description>前情提要 为什么要水这么一篇文章
在把switch借给朋友玩的这段时间，我把目光投向了吃灰已久的3ds&amp;hellip;.
我想要在实机上游玩gba游戏，但是3ds上的模拟器又有各种各样的兼容性问题，达不到eshop里VC金银流畅的游玩体验；宣称能游玩GBA的DSTWO PLUS烧录卡早已停产，某宝/闲鱼的价格居高不下&amp;hellip;经过一番摸索，我找到了可能是现今最好的解决方案。
准备工作   一台BOOT9STARP(B9S)破解的3ds
参考3ds破解手册或者一只火狐大佬整理的教程(推荐)
嫌麻烦的同学可以交给热心摊主处理
  Ultimate GBA VC Injector for 3DS
  汉化版下载链接
  你想要在3ds上运行的GBA游戏ROM文件
这里以漆黑的魅影为例（很棒的GBA宝可梦改版，我一直想在实机上玩）
  GBA 转CIA  打开软件并导入下载好的.gba文件，ROM大小和存档类型会自动确认(汉化版ROM往往是数据库未找到该游戏，请确保选择的正确无误以免影响存档)   gba2cia1 
 gba2cia2 
 填写要转换的VC图标和名称(因为3ds字库的原因建议不要使用中文XD)，设置3D横幅(就是选中这个游戏时3ds上屏的画面)
 gba2cia3 
 gba2cia4 
  设置VC参数并导出CIA文件(注意当转换多个.cia文件时，确保每个文件的产品代码及项目ID都不一样)
 gba2cia5 
  在3ds上安装转换好的.cia文件
  关于如何B9S如何安装cia文件这里不再赘述(实在懒得截图了)
 gba2cia6 
大功告成~
备注事项  据说部分老款3ds对这种方式转换的.cia支持不好，会出现黑屏情况(我的美版老小三反正测试是没问题啦) 港版不支持港版不支持港版不支持 存档类型一定要设置正确  </description>
    </item>
    
    <item>
      <title>Git学习笔记</title>
      <link>https://bestoko.cc/p/gitnotes/</link>
      <pubDate>Mon, 23 Mar 2020 09:00:01 +0800</pubDate>
      
      <guid>https://bestoko.cc/p/gitnotes/</guid>
      <description>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。
Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。
Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。
  learnGit 
常用指令 $ git init # 在当前目录新建一个 Git 代码库 $ git clone [url] # 下载一个项目和它的整个代码历史 $ git config --list # 显示当前的 Git 配置 $ git config -e [--global] # 编辑 Git 配置文件 $ git add # 添加指定文件到暂存区 $ git rm # 删除工作区文件，并且将这次删除放入暂存区 $ git commit -m [message] # 提交暂存区到仓库区 $ git commit -a # 提交工作区自上次 commit 之后的变化，直接到仓库区 $ git commit --amend -m [message] # 使用一次新的 commit，替代上一次提交 如果代码没有任何新变化，则用来改写上一次 commit 的提交信息 $ git commit --amend [file1] [file2] .</description>
    </item>
    
    <item>
      <title>Markdown学习笔记</title>
      <link>https://bestoko.cc/p/markdwonnotes/</link>
      <pubDate>Thu, 12 Mar 2020 09:00:01 +0800</pubDate>
      
      <guid>https://bestoko.cc/p/markdwonnotes/</guid>
      <description>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。
 以下是Markdown的基础语法
~~删除线~~ *斜体* _斜体第二种方法_ **加粗** __加粗的第二种方法__ ___粗斜体___ 两个enter是换行，或者用&amp;lt;/br&amp;gt;标签表示换行 用一行的=或者-表示一级标题和二级标题。如： 一级标题 ======= 二级标题 -------- 也可以在前面加上一到六个#表示标题的1级到6级，标题前加一个空格。如： # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题  无序列表：在前面加上 * 或者 + 或者 - 然后加个空格： * ABC * DEF * GHI + JKL + MNO + PQR - STU - VWX - YZZ 有序列表：数字+英文句点+空格。如下： 1. 呵呵 2. 哈哈 3. 嘿嘿 4. 哼哼 &amp;amp;lt; // 会显示为”&amp;lt;“ &amp;amp;amp; // 会显示为”&amp;amp;“：在 href 属性里面，必须将 &amp;amp; 转变为 &amp;amp;amp; \.</description>
    </item>
    
  </channel>
</rss>
